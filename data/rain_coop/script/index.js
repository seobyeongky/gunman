// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	var resolve, getRequire, require, notFoundError, findFile
	  , extensions = {".js":[".coffee"],".json":[],".css":[],".html":[]};
	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullpath, state) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
			} else {
				tree.push(scope);
				scope = scope[dir];
			}
			if (!scope) throw notFoundError(fullpath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullpath, 1);
			}
			return resolve(scope, tree, 'index', fullpath, 2);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullpath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports };
		fn.call(exports, exports, module, getRequire(scope, tree));
		return module.exports;
	};
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) throw notFoundError(fullpath);
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullpath, state);
	};
	getRequire = function (scope, tree) {
		return function (path) { return require(scope, [].concat(tree), path); };
	};
	return getRequire(modules, []);
})({
	"missile_dodge": {
		"src": {
			"consts.coffee": function (exports, module, require) {
				module.exports = {
				  STATE_READY: 0,
				  STATE_PLAY: 1,
				  STATE_RESULT: 2,
				  BG_KIND: 3,
				  SEA_SEVERTY_LEVELS: 4,
				  MAX_HP: 12,
				  FRAME_RATE: 60
				};
			},
			"dict.json": function (exports, module, require) {
				module.exports = ["가든","가람","가람","가람슬기","가람휘","가림","가온","가온길","가온누리","가온들찬빛","가온뫼","가온해","가이","가자","가장","갈","거늘","거울","겨라","겨레","겨루","겨슬","겨슬","그리","그린나래","글고운","글길","기쁨해","길","길가온","꽃가람","꽃내","꽃내","꽃내음","꽃샘","꽃채운","꽃초롱","꽃큰","나길","나나","나라빛","나라우람","나라찬","나래","나래","나래울","나려","나로","나루해오름","나봄","나빛","나샘","나슬","나예","나오","난길","난새","난슬","날샘","날애","남","남은","내길","내꽃","내담","노아","노을","노을","누리","누리보듬","누리봄","누리알찬","누림","눈꽃","눈솔","뉘","늘다","늘봄","늘봄","늘빈","늘솔길","늘솜","늘예솔","늘찬","다가","다빈","다스리","다슬","다온","다올","다옴","다와","다은","다이","다참","다한","다흰","다힘","도담","도도","도란","도래","도손","도움","동이","두나","두동","두루","두메꽃","두바다찬솔","두빛나래","두온","두힘","드리","드리","든솔","든해","든해솔","들샘","들찬","들찬길","라","라라","라미","라별","라와","란새","렁찬","로다","로와","로운","로지","루다","루라","루리","리네","리라","리리","마디","마루","마루","마루나","마루한","마리","마음","마음새","말근","말글","맑은","맑은가람","맑은누리","매디","모두가람","모두다","모드니","모든","모람","모아","모은","모이","모해","무들","무슬","무지개","물맑","물보라","미나","미나래","미드미","미라","미리별","바다","바로찬글","바론","바름","밝은빛누리예","밝음이","범한","벼리","벼리","별","별글","별솔","별하","보나","보늬","보단","보담","보라나","보람","보르미","보미","보미나","보슬","보아라","보예","봄나","봄시내","봄해","부루","불","비사벌","비치","비치나","빈길","빛글","빛길","빛다","빛솔","빛초롱","새길","새꽃","새나","새난","새누","새늘","새론","새밝","새솔","새얀","세련","세리","세움","세이","세찬","소리","소미","소아","소예","솔관","솔길","솔빛길","솔잎","솔찬","수련","수리","슬기","슬아","슬아라","슬예","슬옹","슬우","슬찬","승아","승아","시내","시원","아라","아라","아란","아련나래","아롱별","아름나","아리솔","아리알찬","안찬","알","알찬마루","알찬바로","알찬해","얀","얀별","얀새","얼","엄지","에가득","에다","여름","영글","예님","예다움","외솔","외솔","우람늘","우솔","움찬","으뜸","은새","은소라","은솔","은솜","은송이","이든샘","이루리","이루리라","이룩","이솔","이송이","이플","잎새","자랑","자올","잔디","재마루","재미","재바우","재찬","제나","제철","조롱목","조은","조히","종달","주나","주리","주미","지나","지니","지은","지음","진나","진달래","진샘","진솔","진이","차나","차미","차분","차분나래","차오름","착히","찬","찬내","찬놀","찬누리","찬늘","찬늘봄","찬들","찬들","찬솔","찬솔나라","찬솔큰","찬슬","찬슬기","참","참이","참이삭","채움늘","초고리","초롬","초롱","초롱","초롱꽃","치리","크나","크심","큰가람","큰길","큰깃","큰꽃","큰꽃늘","큰꽃들","큰나라","큰나래","큰돌찬","큰돛","큰마루","큰말","큰맘","큰모듬","큰모음","큰뫼","큰솔","큰아","큰애","큰재","큰힘","클","키움","키클","타고나","터전","터큰","텃골","텃골돌샘터","토리","통꽃","튼동","튼싹","튼트나","튼튼","틀큰","티나","파라","파라나","파라미","파란","파랑","파랑새","퍼리","펴라","푸르","푸르나","푸르내","푸르니","푸른나래","푸른나무","푸른들","푸른마을","풀잎","풀큰","풋내","피네","피라","피리","피어나","핀아","하나","하늬","하람","하랑","하련솔","하예라","하예진","한","한가람","한결","한길찬","한내","한내","한누리","한별나라","한봄찬","한빛","한빛","한샘가온","한울","해가빛","해긴","해길","해나","해늘","해님꽃","해련","해비치","해사랑해","해샘찬","해솔","해찬나래","해찬솔","환찬","환히찬","횃불","희라","흰가람","흰꽃","힘차","힘찬","▣","\r","■","\r","■","해오름달","시샘달","물오름달","잎새달","푸른달","누리달","견우직녀달","타오름달","열매달","하늘연달","미틈달","매듭달","\r","■","1.하루","11.열하루","21.스물하루","▣","\r","가납사니","가년스럽다","가늠","가라사니","가람","가래다","가래톳","가론","가루다","가말다","가멸다","가무리다","가분하다·가붓하다","가살","가시버시","가온길","가온누리","가우리","가위춤","가장이","가재기","가직하다","가축","가탈","각다분하다","간동하다","간정되다","갈개꾼","갈래다","갈마보다","갈무리","감잡히다","강짜를","강파르다","갖바치","갖추다","개골창","개구멍받이","개맹이","개사망","개어귀","개차반","개평","객쩍다","거니채다","거레","거우다","건목","건잠머리","걸싸다","걸쩍거리다","걸태질","게염","게정","겨끔내기","겨르로이","겨리","겯고틀다","결곡하다","결두리","결딴","고거리","고거이","고빗사위","고뿔","고삿","고수련","고수머리","고타야","곧추다","골갱이","골막하다","곰비임비","곰살궂다","곰상스럽다","곰파다","곱살끼다","공성이","공중제비","공치하다","괴덕","구다라","구듭","구메","구쁘다","구성없다","구성지다","구순하다","구실","구어박다","구완","구유","국으로","굴레","굴침스럽다","굴타리먹다","굴통이","굼닐다","굽도리","굽바자","궁따다","귀살쩍다","그느다","그느르다","그루잠","그루터기","그린나래","그린내","그린비","그미","그악하다","금새","기를","기이다","길가온","길라잡이","길마","길미","길섶","길제","길품","김바리","까대기","까막과부","까막까치","까미","깔죽없다","깜냥","깜부기","깨단하다","꺼병이","꺽지다","꼬꼬지","꼬두람이","꼬리별","꼲다","꽃가람","꽃내음","꽃샘","꽃샘바람","꽃잠","꾀꾀로","꿰미","끄나풀","끄느름하다","끌끌하다","나래","나르샤","나린","나릿물","나부대다","나비잠","난든집","난이","남새","남우세","남진계집","낫잡다","낳이","내남없이","내숭","너널","너비","너울","넉가래","넉장거리","넌더리","널출지다","노가리","노고지리","노닥이다","노드매기","노량으로","노루잠","노적가리","노총","놀금","높새","눈거칠다","눈바래기","눈비음","눈썰미","눈엣가시","느껍다","느루","느루먹다","는개","늘비하다","늘솔길","늘해랑","늠그다","능","능갈치다","늦","늦마","늦사리","다님길","다따가","다락같다","다랑귀","다소니","다소다","다솜","다원","다직해야","다흰","닦아세우다","단물나다","단미","달구치다","달랑쇠","달보드레하다","달포","답치기","당나발붙다","당도리","닻별","대갚음","대두리","댓바람","댕기다","더껑이","더께","더치다","더펄이","덖다","던적스럽다","덜퍽지다","덤받이","덤터기","덧거칠다","덧게비","덧두리","덩둘하다","덩저리","도거리","도닐다","도담도담","도두보다","도드미","도란도란","도래솔","도린결","도사리","도섭","도스르다","도투락","도파니","돈바르다","돈사다","돌개바람","동곳빼다","동그마니","동뜨다","동아리","동이","동자아치","동티","되모시","되술래잡히다","되지기","되퉁스럽다","된","된바람","될성부르다","두남두다","두동지다","두례","두멍","둔치","둥개다","뒤란","뒤스르다","뒤웅박","뒤통수(를)치다","뒨장질","뒷갈망","뒷귀","드난","드레","드림흥정","드티다","들거지","들마","들메","들썽하다","들입다","들피","듬쑥하다","따리꾼","딸각발이","떠세","떡심이","떨거지","뚜쟁이","뚝벌씨","뚱기다","뜨께질","뜨악하다","뜯게","라온제나","라온하제","라온힐조","마고자","마닐마닐","마디다","마뜩하다","마루","마름","마름질","마소두래기","마수걸다","마장스럽다","마전","마파람","말결","말재기","말코지","맛조이","매개","매골","매나니","매지구름","매캐하다","맨드라미","맨드리","맨망","맵자하다","맷가마리","맹문","머드러기","머줍다","먼산바라기","메꿎다","메지","멧부리","멱차다","모가비","모꼬지","모람모람","모래톱","모르쇠","모주망태","모집다","모춤하다","목매기","몽구리","몽니","몽따다","몽종하다","몽짜","몽태치다","무꾸리","무녀리","무드럭지다","무람없다","무릎마춤","무서리","무수다","무싯날","무텅이","묵새기다","물강스럽다","물꼬","물마","물보낌","물부리","물비늘","물수제비뜨다","물초","뭉근하다","미대다","미르","미리내","미립","미쁘다","미투리","민낯","민둥산","민충하다","민틋하다","민패","밀막다","밀절미","바오","바자위다","바장이다","바투","반거들충이","반기","반살미","반색","반자받다","반지빠르다","받내다","발림","발발다","발쇠","방물","방자","방자고기","방짜","방패막이","배갯잇","배내","배냇짓","배때벗다","배메기","버겁다","버금","버덩","버력","버르집다","버름하다","벋대다","벌충","벗","베돌다","벼리","벼리,","벼리다","변죽","별찌","볏가리","보깨다","보꾹","보드기","보쟁이다","보짱","본치","볼멘소리","볼모","볼우물","부넘기","부닐다","부대끼다","부라퀴","부르터나다","부아나다","부지깽이","북새","북새바람","붓날다","붓방아","붙박이","비나리","비나리치다","비를","비마중","비말","비설거지","비커리","빌미","빌붙다","빗물이","빙충맞다","빚지시","뻑뻑이","뿌다구니","사그랑이","사금파리","사나래","사달","사람멀미","사로자다","사부랑사부랑","사시랑이","사위다","사재기","사태","사품","삭신","삭정이","삯메기","산다라","산돌림","살갑다","살강","살거리","살붙이","살소매","살손(을)붙이다","살피","삼짇날","삼태기","삼하다","상고대","새,","새경","새라","새룽이","새물내","샘바리","샛바람","샛별","생무지","생인손","생채기","생청","생화","서름하다","서릊다","서리서리","섟","섟삭다","선겁다","선바람","선불걸다","선술집","선웃음","섣부르다","설멍하다","설면하다","설피다","섬돌","섬서하다","성금","성기다","성마르다","세나다","셈나다","셈차리다","소담하다","소댕","소두","소드락질","소래기","소롱하다","소마","소마소마","소소리바람","소수나다","소양배양하다","소태같다","속종","솎다","손","손대기","손떠퀴","손바람","손방","손사래","손타다","손포","수발","수지니","수채","수피아","숙수그레하다","숙지다","숨베","숯","숱","슈룹","스스럼","습습하다","승겁들다","시게","시나브로","시뜻하다","시래기","시르죽다","시름없다","시먹다","시쁘다","시설궂다","시세","시앗","시역","시위","시적거리다","시치다","신망스럽다","실랑이","실큼하다","실터","실팍하다","심드렁하다","심마니","심사미","싸개통","싸도둑","싹수","쌩이질","쏘개질","쓰레질","쓸까스르다","쓿다","아가씨","아귀차다","아기똥하다","아니리","아띠","아라","아라가야","아람","아람치","아련하다","아름드리","아리수","아리아","아리잠작하다","아미","아사","아스라이","아우르다","아이서다","아주버니","아퀴","아퀴짓다","아토","악도리","안날","안다미","안다미로","안를다","안차다","안팎장사","알섬","알심","알짬","알천","암상","암팡지다","앙금","앙달머리","앙세다","앙증하다","앙짜","앞바람","애면글면","애물","애벌갈이","애성이","애오라지","애옥살이","앤생이","앵돌아지다","야바위","야발","야비다리","야수다","야지랑스럽다","야짓","약비나다","얌생이","양지머리","어거리풍년","어니눅다","어엿하다","어줍다","언걸","언구럭","언막이","얼렁장사","얼레","얼레살풀다","업시름","엇부루기","엉거능축하다","엉겁","엉구다","엉리","엉세판","에끼다","에다","에멜무지로","에우다","에움길","여낙낙하다","여남은","여루다","여리꾼","여우별","여우비","여정하다","여줄가리","역성","열고나다","열없다","영바람","영절스럽다","영판","예그리나","예제없이","옛살비","오금","오달지다","오례쌀","오릇하다","오비다","오쟁이지다","오지랖넓다","옥셈","온","온누리","온새미로","올되다","올리사랑","올무","올케","옴니암니","옷깃차례","옹골지다","옹아리","옹추","옹춘마니","왕청되다","왜골","왜자하다","왜장치다","욕지기","용수","용심","용지","용천하다","용춤","용트림","우금","우꾼하다","우두망찰하다","우듬지","우렁잇속","우멍하다","우선하다","우세","우수리","우접다","울대","울력","움딸","웁쌀","웃날들다","웃비","워낭","윗바람","윤슬","으르다","은가람","은가비","은결들다","은사죽음","의초","이내","이든","이르집다","이물","이악하다","이울다","이지다","임","입찬말","잇바디","자귀","자닝하다","자리끼","자리끼","자리보전","자맥질","자발없다","자부지","자빡대다","자투리","잔다리밟다","잔달음","잔질다","잡도리","잡을손","장돌림","장맞이","장족박","잦히다","재강","재우치다","저어하다","적바람(뒤에","적바르다","점지","정수리","제키다","조라떨다","조리차하다","조치개","족대기다","졸가리","졸들다","좁쌀여우","종요롭다","좆다","주니","주럽","주릅","주저롭다","주저리","주전부리","주접","줏대잡이","중절거리다","쥐락펴락","쥘손","즈믄","지다위","지돌이","지망지망히","지실","지위","지청구","직수굿하다","진번질하다","진솔","질통","짐짓","집알이","짜개","짜발량이","짜장","짝자꿍이","째다","째마리","쭉정이","찌그렁이","찜부럭","차돌박이","차반","척(隻)을","천둥","천둥지기","천세나다","첫밗","초들다","초라떼다","초아","추레하다","추지다","치사람","치신없다","커나다","켕기다","코뚜레","코숭이","콩케팥케","큰상물림","킷값","타끈하다","타니","타래","타래버선","타울거리다","터럭","터알","톡탁치다","투미하다","튀하다","트레바리","틋","파니","파임내다","판들다","판수","퍼르퍼르","포롱거리다","푸네기","푸닥거리","푸르미르","푸실","푸접없다","푹하다","푼더분하다","푼푼하다","풀무","품앗이","풍년(豊年)","피새","피천","하나린","하냥다짐","하늬","하늬바람","하람","하르르하다","하릅","하리놀다","하리다","하리들다","하릴없다","하마하마","하비다","하슬라","하야로비","하제","한겻","한둔","한별","한사리","한울","한풀","할경","함진아비","함초롬하다","함함하다","핫아비","핫어미","핫옷","해거름","해껏","해소수","해찰","해찰하다","행짜","허구리","허닥하다","허대다","허드레","허룩하다","허룽거리다","허릅숭이","허물하다","허발","허방","허벅지다","허섭쓰레기","허수하다","허출하다","헛물켜다","헛장","헤먹다","헤살","헤식다","헤윰","호다","호드기","호락질","홀앗이","홀지다","화수분","확","홰","회두리","훈감하다","휘들램","흐노니","흐드러지다","흥글방망이놀다","희나리","희떱다","희치희치","힐조"];
			},
			"index.coffee": function (exports, module, require) {
				var FIRST_STATE, STATE_PLAY, STATE_READY, STATE_RESULT, current_stage, env, next_scene, scene, scenes, _ref,
				  __slice = [].slice;

				_ref = require('./consts'), STATE_READY = _ref.STATE_READY, STATE_PLAY = _ref.STATE_PLAY, STATE_RESULT = _ref.STATE_RESULT;

				FIRST_STATE = STATE_PLAY;

				scenes = {};

				env = {
				  tick: 0,
				  state: FIRST_STATE,
				  players: Player.all()
				};

				scenes[STATE_READY] = require('./ready');

				scenes[STATE_PLAY] = require('./play');

				scenes[STATE_RESULT] = require('./result');

				current_stage = FIRST_STATE;

				scene = null;

				next_scene = function() {
				  return scene = scenes[current_stage](env);
				};

				next_scene();

				onPlayerInput(function() {
				  var args;
				  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				  scene.on_player_input.apply(scene, args);
				  if (current_stage !== env.state) {
				    current_stage = env.state;
				    return next_scene();
				  }
				});

				onFrameMove(function() {
				  var args;
				  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				  scene.on_frame_move.apply(scene, args);
				  if (current_stage !== env.state) {
				    current_stage = env.state;
				    next_scene();
				  }
				  return env.tick++;
				});
			},
			"play.coffee": function (exports, module, require) {
				var BG_KIND, FRAME_RATE, INPUT_CHAT_MESSAGE, MAX_HP, SEA_SEVERTY_LEVELS, STATE_READY, dict, make_message_text, stages, textures, _, _i, _j, _ref, _results, _results1,
				  __slice = [].slice;

				INPUT_CHAT_MESSAGE = require('./system/consts').INPUT_CHAT_MESSAGE;

				_ref = require('./consts'), STATE_READY = _ref.STATE_READY, BG_KIND = _ref.BG_KIND, SEA_SEVERTY_LEVELS = _ref.SEA_SEVERTY_LEVELS, MAX_HP = _ref.MAX_HP, FRAME_RATE = _ref.FRAME_RATE;

				stages = require('./stages');

				dict = require('./dict.json');

				_ = require('underscore');

				textures = {};

				(function() {
				  _results = [];
				  for (var _i = 0; 0 <= BG_KIND ? _i < BG_KIND : _i > BG_KIND; 0 <= BG_KIND ? _i++ : _i--){ _results.push(_i); }
				  return _results;
				}).apply(this).forEach(function(i) {
				  var t;
				  t = new Texture;
				  t.loadFromFile("textures/bg_" + i + ".png");
				  return textures["bg_" + i] = t;
				});

				(function() {
				  _results1 = [];
				  for (var _j = 0; 0 <= SEA_SEVERTY_LEVELS ? _j < SEA_SEVERTY_LEVELS : _j > SEA_SEVERTY_LEVELS; 0 <= SEA_SEVERTY_LEVELS ? _j++ : _j--){ _results1.push(_j); }
				  return _results1;
				}).apply(this).forEach(function(i) {
				  var t;
				  t = new Texture;
				  t.loadFromFile("textures/sea_" + i + ".png");
				  return textures["sea_" + i] = t;
				});

				make_message_text = function(msg, color) {
				  var t;
				  t = new Text;
				  t.characterSize = 50;
				  t.string = msg;
				  t.x = 0.5 * UI.width;
				  t.y = 0.5 * UI.height;
				  t.originX = 0.5 * t.width;
				  t.originY = 0.5 * t.height;
				  t.color = color;
				  return t;
				};

				module.exports = function(env) {
				  var bg, chat, checks, count, effects, fallen_texts, hp_text, lv, make_background, make_fallen_text, make_hp_text, make_ranking_text, make_sea, make_timeleft_text, next_stage, nr_fallen, players, playing, ranking_text, render, sea, stage, stage_start, timeleft_text, update, update_fallen_texts, when_;
				  players = env.players;
				  count = 0;
				  fallen_texts = [];
				  bg = null;
				  sea = null;
				  hp_text = null;
				  timeleft_text = null;
				  stage = stages[0];
				  effects = [];
				  when_ = [];
				  nr_fallen = 0;
				  lv = 0;
				  playing = true;
				  ranking_text = null;
				  env.stats = players.map(function() {
				    return {
				      nr_destroy: 0
				    };
				  });
				  make_background = function() {
				    var s, texture_index, update_texture;
				    texture_index = 0;
				    s = new Sprite;
				    s.x = 0;
				    s.y = 0;
				    s.originX = 0;
				    s.originY = 0;
				    update_texture = function() {
				      var t;
				      t = textures["bg_" + texture_index];
				      s.scaleX = UI.width / t.width;
				      s.scaleY = UI.height / t.height;
				      return s.texture = t;
				    };
				    s.change = function() {
				      if (++texture_index >= BG_KIND) {
				        texture_index = 0;
				      }
				      return update_texture();
				    };
				    update_texture();
				    return s;
				  };
				  bg = make_background();
				  make_sea = function() {
				    var s, severty, update_texture;
				    severty = 0;
				    s = new Sprite;
				    s.x = 0;
				    s.y = UI.height;
				    s.originX = 0;
				    update_texture = function() {
				      var t;
				      t = textures["sea_" + severty];
				      s.originY = t.height;
				      s.scaleX = UI.width / t.width;
				      s.scaleY = s.scaleX;
				      return s.texture = t;
				    };
				    s.update = function() {
				      var ratio;
				      ratio = Math.min(nr_fallen / MAX_HP, 1);
				      severty = Math.floor(ratio * (SEA_SEVERTY_LEVELS - 1));
				      return update_texture();
				    };
				    update_texture();
				    return s;
				  };
				  sea = make_sea();
				  make_hp_text = function() {
				    var self;
				    self = new Text;
				    self.characterSize = 45;
				    self.update = function() {
				      self.string = "" + (Math.max(MAX_HP - nr_fallen, 0)) + "/" + MAX_HP;
				      return self.originX = self.width;
				    };
				    self.update();
				    self.x = UI.width - 20;
				    self.y = UI.height - 100;
				    self.color = {
				      r: 255,
				      g: 255,
				      b: 0,
				      a: 255
				    };
				    self.originY = 0;
				    return self;
				  };
				  hp_text = make_hp_text();
				  make_timeleft_text = function() {
				    var STAGE_TIME, begin_at, self;
				    self = new Text;
				    self.characterSize = 35;
				    STAGE_TIME = stage.STAGE_TIME;
				    begin_at = count;
				    self.update = function() {
				      self.string = "남은 시간 : " + (Math.max(0, Math.floor((begin_at + STAGE_TIME - count) / FRAME_RATE))) + "초";
				      return self.originX = self.width;
				    };
				    self.update();
				    self.x = UI.width - 20;
				    self.y = 20;
				    self.color = {
				      r: 0,
				      g: 255,
				      b: 0,
				      a: 255
				    };
				    return self;
				  };
				  timeleft_text = make_timeleft_text();
				  make_ranking_text = function() {
				    var t;
				    t = new Text;
				    t.characterSize = 22;
				    t.update = function() {
				      var a, max_len, sorted, stats, wrapped, _k, _l, _len, _results2;
				      stats = env.stats;
				      wrapped = stats.map(function(a, i) {
				        return _.extend({
				          pid: i
				        }, a);
				      });
				      sorted = _.sortBy(wrapped, function(a) {
				        return a.nr_destroy;
				      });
				      sorted.reverse();
				      t.string = "";
				      for (_k = 0, _len = sorted.length; _k < _len; _k++) {
				        a = sorted[_k];
				        t.string += '\n';
				        t.string += "" + players[a.pid].name + " : " + a.nr_destroy + "개 파괴";
				      }
				      max_len = _.reduce(t.string.split('\n'), (function(memo, text) {
				        return Math.max(memo, text.length);
				      }), 0);
				      t.string = ((function() {
				        _results2 = [];
				        for (var _l = 0; 0 <= max_len ? _l < max_len : _l > max_len; 0 <= max_len ? _l++ : _l--){ _results2.push(_l); }
				        return _results2;
				      }).apply(this).map(function() {
				        return '=';
				      })).join('') + t.string;
				      t.originX = t.width;
				    };
				    t.update();
				    t.x = UI.width - 20;
				    t.y = 0.2 * UI.height;
				    return t;
				  };
				  ranking_text = make_ranking_text();
				  make_fallen_text = function() {
				    var born_time, self;
				    self = new Text;
				    self.characterSize = 25;
				    self.string = dict[Math.floor(Math.random() * dict.length)];
				    self.originX = 0.5 * self.width;
				    self.originY = 0.5 * self.height;
				    self.x = Math.random() * (0.5 * UI.width - self.width) + 0.5 * self.width;
				    self.y = -self.height;
				    self.color = {
				      r: 0,
				      g: 0,
				      b: 0,
				      a: 255
				    };
				    born_time = count;
				    self.update = function() {
				      var WORD_LIVING_TICKS;
				      WORD_LIVING_TICKS = stage.WORD_LIVING_TICKS;
				      self.y = -self.height + ((count - born_time) / WORD_LIVING_TICKS) * UI.height;
				      if (count - born_time > WORD_LIVING_TICKS) {
				        self.should_dead = true;
				      }
				    };
				    self.run_disappear_action = function() {
				      var lasttime, _name;
				      effects.push(self);
				      [1, 2, 3, 4, 5, 6, 7, 8, 9].forEach(function(i) {
				        var time, _name;
				        time = when_[_name = count + i] != null ? when_[_name = count + i] : when_[_name] = [];
				        return time.push(function() {
				          self.scaleX *= 0.9;
				          return self.scaleY *= 0.9;
				        });
				      });
				      lasttime = when_[_name = count + 11] != null ? when_[_name = count + 11] : when_[_name] = [];
				      return lasttime.push(function() {
				        return effects.splice(effects.indexOf(self), 1);
				      });
				    };
				    return self;
				  };
				  update_fallen_texts = function() {
				    var WORD_GENERATION_PERIOD, text, _k, _len;
				    WORD_GENERATION_PERIOD = stage.WORD_GENERATION_PERIOD;
				    if (count % WORD_GENERATION_PERIOD === 0) {
				      fallen_texts.push(make_fallen_text());
				    }
				    for (_k = 0, _len = fallen_texts.length; _k < _len; _k++) {
				      text = fallen_texts[_k];
				      text.update();
				    }
				    fallen_texts.forEach(function(t) {
				      if (t.should_dead) {
				        return nr_fallen++;
				      }
				    });
				    return fallen_texts = _.reject(fallen_texts, function(t) {
				      return t.should_dead;
				    });
				  };
				  checks = function() {
				    var t, time, _name;
				    if (playing) {
				      if (nr_fallen >= MAX_HP) {
				        t = make_message_text("게임 오버!", {
				          r: 255,
				          g: 0,
				          b: 0,
				          a: 255
				        });
				        effects.push(t);
				        time = when_[_name = count + 3 * 60] != null ? when_[_name = count + 3 * 60] : when_[_name] = [];
				        time.push(function() {
				          var idx;
				          idx = effects.indexOf(t);
				          if (idx === -1) {
				            throw new Error("hul");
				          }
				          effects.splice(idx, 1);
				          return env.state = STATE_READY;
				        });
				        return playing = false;
				      }
				    }
				  };
				  update = function() {
				    var e, list, _k, _len;
				    while (when_[count] != null) {
				      list = when_[count];
				      delete when_[count];
				      for (_k = 0, _len = list.length; _k < _len; _k++) {
				        e = list[_k];
				        e();
				      }
				    }
				    if (playing) {
				      update_fallen_texts();
				      hp_text.update();
				      timeleft_text.update();
				      ranking_text.update();
				      sea.update();
				    }
				    return checks();
				  };
				  render = function() {
				    var effect, text, _k, _l, _len, _len1;
				    UI.draw(bg);
				    UI.draw(sea);
				    for (_k = 0, _len = fallen_texts.length; _k < _len; _k++) {
				      text = fallen_texts[_k];
				      UI.draw(text);
				    }
				    for (_l = 0, _len1 = effects.length; _l < _len1; _l++) {
				      effect = effects[_l];
				      UI.draw(effect);
				    }
				    UI.draw(hp_text);
				    UI.draw(timeleft_text);
				    return UI.draw(ranking_text);
				  };
				  chat = function(pid, msg) {
				    var matched;
				    matched = _.find(fallen_texts, function(t) {
				      return t.string === msg;
				    });
				    if (matched != null) {
				      env.stats[pid].nr_destroy++;
				      matched.color = players[pid].color;
				      matched.run_disappear_action();
				      return fallen_texts.splice(fallen_texts.indexOf(matched), 1);
				    }
				  };
				  next_stage = function() {
				    stage = stages[++lv];
				    if (stage == null) {
				      throw new Error("all stage cleared");
				    }
				  };
				  stage_start = function() {
				    var STAGE_TIME, a, _name;
				    STAGE_TIME = stage.STAGE_TIME;
				    a = when_[_name = count + STAGE_TIME] != null ? when_[_name = count + STAGE_TIME] : when_[_name] = [];
				    return a.push(function() {
				      var cong;
				      cong = new Text;
				      return cong.string = "스테이지 성공!!!";
				    });
				  };
				  return {
				    on_frame_move: function() {
				      update();
				      render();
				      count++;
				    },
				    on_player_input: function() {
				      var args, pid, type;
				      pid = arguments[0], type = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
				      if (type === INPUT_CHAT_MESSAGE) {
				        return chat(pid, args[0]);
				      }
				    }
				  };
				};
			},
			"ready.coffee": function (exports, module, require) {
				var STATE_PLAY;

				STATE_PLAY = require('./consts').STATE_PLAY;

				module.exports = function(env) {
				  var count, players, text, when_;
				  players = env.players;
				  count = 0;
				  when_ = {};
				  text = new Text;
				  text.string = "산성비를 막아라!!";
				  text.x = 0.3 * UI.width;
				  text.y = 0.3 * UI.height;
				  text.characterSize = 25;
				  when_[5 * 60] = function() {
				    return text.string = "준비하세요!";
				  };
				  [3, 2, 1].forEach(function(i) {
				    return when_[6 * 60 + (3 - i) * 60] = function() {
				      return text.string += "..." + i;
				    };
				  });
				  when_[9 * 60] = function() {
				    return env.state = STATE_PLAY;
				  };
				  return {
				    on_frame_move: function() {
				      var the_event;
				      the_event = when_[count++];
				      if (typeof the_event === "function") {
				        the_event();
				      }
				      return UI.draw(text);
				    },
				    on_player_input: function() {}
				  };
				};
			},
			"result.coffee": function (exports, module, require) {
				module.exports = function() {
				  return {
				    on_frame_move: function() {},
				    on_player_input: function() {}
				  };
				};
			},
			"stages.coffee": function (exports, module, require) {
				module.exports = [
				  {
				    WORD_LIVING_TICKS: 6 * 60,
				    WORD_GENERATION_PERIOD: 60,
				    STAGE_TIME: 30 * 60
				  }
				];
			},
			"system": {
				"consts.js": function (exports, module, require) {
					out = {}
					
					// inputs
					out.INPUT_LEFT_MOUSE_DOWN = 0
					out.INPUT_LEFT_MOUSE_UP = 1
					out.INPUT_RIGHT_MOUSE_DOWN = 2
					out.INPUT_RIGHT_MOUSE_UP = 3
					out.INPUT_MOUSE_MOVE = 4
					out.INPUT_KEY_DOWN = 5
					out.INPUT_KEY_UP = 6
					out.INPUT_CHAT_MESSAGE = 7
					
					module.exports = out
				}
			}
		}
	},
	"underscore": {
		":mainpath:": "underscore.js",
		"underscore.js": function (exports, module, require) {
			//     Underscore.js 1.7.0
			//     http://underscorejs.org
			//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
			//     Underscore may be freely distributed under the MIT license.

			(function() {

			  // Baseline setup
			  // --------------

			  // Establish the root object, `window` in the browser, or `exports` on the server.
			  var root = this;

			  // Save the previous value of the `_` variable.
			  var previousUnderscore = root._;

			  // Save bytes in the minified (but not gzipped) version:
			  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

			  // Create quick reference variables for speed access to core prototypes.
			  var
			    push             = ArrayProto.push,
			    slice            = ArrayProto.slice,
			    concat           = ArrayProto.concat,
			    toString         = ObjProto.toString,
			    hasOwnProperty   = ObjProto.hasOwnProperty;

			  // All **ECMAScript 5** native function implementations that we hope to use
			  // are declared here.
			  var
			    nativeIsArray      = Array.isArray,
			    nativeKeys         = Object.keys,
			    nativeBind         = FuncProto.bind;

			  // Create a safe reference to the Underscore object for use below.
			  var _ = function(obj) {
			    if (obj instanceof _) return obj;
			    if (!(this instanceof _)) return new _(obj);
			    this._wrapped = obj;
			  };

			  // Export the Underscore object for **Node.js**, with
			  // backwards-compatibility for the old `require()` API. If we're in
			  // the browser, add `_` as a global object.
			  if (typeof exports !== 'undefined') {
			    if (typeof module !== 'undefined' && module.exports) {
			      exports = module.exports = _;
			    }
			    exports._ = _;
			  } else {
			    root._ = _;
			  }

			  // Current version.
			  _.VERSION = '1.7.0';

			  // Internal function that returns an efficient (for current engines) version
			  // of the passed-in callback, to be repeatedly applied in other Underscore
			  // functions.
			  var createCallback = function(func, context, argCount) {
			    if (context === void 0) return func;
			    switch (argCount == null ? 3 : argCount) {
			      case 1: return function(value) {
			        return func.call(context, value);
			      };
			      case 2: return function(value, other) {
			        return func.call(context, value, other);
			      };
			      case 3: return function(value, index, collection) {
			        return func.call(context, value, index, collection);
			      };
			      case 4: return function(accumulator, value, index, collection) {
			        return func.call(context, accumulator, value, index, collection);
			      };
			    }
			    return function() {
			      return func.apply(context, arguments);
			    };
			  };

			  // A mostly-internal function to generate callbacks that can be applied
			  // to each element in a collection, returning the desired result — either
			  // identity, an arbitrary callback, a property matcher, or a property accessor.
			  _.iteratee = function(value, context, argCount) {
			    if (value == null) return _.identity;
			    if (_.isFunction(value)) return createCallback(value, context, argCount);
			    if (_.isObject(value)) return _.matches(value);
			    return _.property(value);
			  };

			  // Collection Functions
			  // --------------------

			  // The cornerstone, an `each` implementation, aka `forEach`.
			  // Handles raw objects in addition to array-likes. Treats all
			  // sparse array-likes as if they were dense.
			  _.each = _.forEach = function(obj, iteratee, context) {
			    if (obj == null) return obj;
			    iteratee = createCallback(iteratee, context);
			    var i, length = obj.length;
			    if (length === +length) {
			      for (i = 0; i < length; i++) {
			        iteratee(obj[i], i, obj);
			      }
			    } else {
			      var keys = _.keys(obj);
			      for (i = 0, length = keys.length; i < length; i++) {
			        iteratee(obj[keys[i]], keys[i], obj);
			      }
			    }
			    return obj;
			  };

			  // Return the results of applying the iteratee to each element.
			  _.map = _.collect = function(obj, iteratee, context) {
			    if (obj == null) return [];
			    iteratee = _.iteratee(iteratee, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        results = Array(length),
			        currentKey;
			    for (var index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      results[index] = iteratee(obj[currentKey], currentKey, obj);
			    }
			    return results;
			  };

			  var reduceError = 'Reduce of empty array with no initial value';

			  // **Reduce** builds up a single result from a list of values, aka `inject`,
			  // or `foldl`.
			  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
			    if (obj == null) obj = [];
			    iteratee = createCallback(iteratee, context, 4);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index = 0, currentKey;
			    if (arguments.length < 3) {
			      if (!length) throw new TypeError(reduceError);
			      memo = obj[keys ? keys[index++] : index++];
			    }
			    for (; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      memo = iteratee(memo, obj[currentKey], currentKey, obj);
			    }
			    return memo;
			  };

			  // The right-associative version of reduce, also known as `foldr`.
			  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
			    if (obj == null) obj = [];
			    iteratee = createCallback(iteratee, context, 4);
			    var keys = obj.length !== + obj.length && _.keys(obj),
			        index = (keys || obj).length,
			        currentKey;
			    if (arguments.length < 3) {
			      if (!index) throw new TypeError(reduceError);
			      memo = obj[keys ? keys[--index] : --index];
			    }
			    while (index--) {
			      currentKey = keys ? keys[index] : index;
			      memo = iteratee(memo, obj[currentKey], currentKey, obj);
			    }
			    return memo;
			  };

			  // Return the first value which passes a truth test. Aliased as `detect`.
			  _.find = _.detect = function(obj, predicate, context) {
			    var result;
			    predicate = _.iteratee(predicate, context);
			    _.some(obj, function(value, index, list) {
			      if (predicate(value, index, list)) {
			        result = value;
			        return true;
			      }
			    });
			    return result;
			  };

			  // Return all the elements that pass a truth test.
			  // Aliased as `select`.
			  _.filter = _.select = function(obj, predicate, context) {
			    var results = [];
			    if (obj == null) return results;
			    predicate = _.iteratee(predicate, context);
			    _.each(obj, function(value, index, list) {
			      if (predicate(value, index, list)) results.push(value);
			    });
			    return results;
			  };

			  // Return all the elements for which a truth test fails.
			  _.reject = function(obj, predicate, context) {
			    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
			  };

			  // Determine whether all of the elements match a truth test.
			  // Aliased as `all`.
			  _.every = _.all = function(obj, predicate, context) {
			    if (obj == null) return true;
			    predicate = _.iteratee(predicate, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index, currentKey;
			    for (index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      if (!predicate(obj[currentKey], currentKey, obj)) return false;
			    }
			    return true;
			  };

			  // Determine if at least one element in the object matches a truth test.
			  // Aliased as `any`.
			  _.some = _.any = function(obj, predicate, context) {
			    if (obj == null) return false;
			    predicate = _.iteratee(predicate, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index, currentKey;
			    for (index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      if (predicate(obj[currentKey], currentKey, obj)) return true;
			    }
			    return false;
			  };

			  // Determine if the array or object contains a given value (using `===`).
			  // Aliased as `include`.
			  _.contains = _.include = function(obj, target) {
			    if (obj == null) return false;
			    if (obj.length !== +obj.length) obj = _.values(obj);
			    return _.indexOf(obj, target) >= 0;
			  };

			  // Invoke a method (with arguments) on every item in a collection.
			  _.invoke = function(obj, method) {
			    var args = slice.call(arguments, 2);
			    var isFunc = _.isFunction(method);
			    return _.map(obj, function(value) {
			      return (isFunc ? method : value[method]).apply(value, args);
			    });
			  };

			  // Convenience version of a common use case of `map`: fetching a property.
			  _.pluck = function(obj, key) {
			    return _.map(obj, _.property(key));
			  };

			  // Convenience version of a common use case of `filter`: selecting only objects
			  // containing specific `key:value` pairs.
			  _.where = function(obj, attrs) {
			    return _.filter(obj, _.matches(attrs));
			  };

			  // Convenience version of a common use case of `find`: getting the first object
			  // containing specific `key:value` pairs.
			  _.findWhere = function(obj, attrs) {
			    return _.find(obj, _.matches(attrs));
			  };

			  // Return the maximum element (or element-based computation).
			  _.max = function(obj, iteratee, context) {
			    var result = -Infinity, lastComputed = -Infinity,
			        value, computed;
			    if (iteratee == null && obj != null) {
			      obj = obj.length === +obj.length ? obj : _.values(obj);
			      for (var i = 0, length = obj.length; i < length; i++) {
			        value = obj[i];
			        if (value > result) {
			          result = value;
			        }
			      }
			    } else {
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index, list) {
			        computed = iteratee(value, index, list);
			        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
			          result = value;
			          lastComputed = computed;
			        }
			      });
			    }
			    return result;
			  };

			  // Return the minimum element (or element-based computation).
			  _.min = function(obj, iteratee, context) {
			    var result = Infinity, lastComputed = Infinity,
			        value, computed;
			    if (iteratee == null && obj != null) {
			      obj = obj.length === +obj.length ? obj : _.values(obj);
			      for (var i = 0, length = obj.length; i < length; i++) {
			        value = obj[i];
			        if (value < result) {
			          result = value;
			        }
			      }
			    } else {
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index, list) {
			        computed = iteratee(value, index, list);
			        if (computed < lastComputed || computed === Infinity && result === Infinity) {
			          result = value;
			          lastComputed = computed;
			        }
			      });
			    }
			    return result;
			  };

			  // Shuffle a collection, using the modern version of the
			  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
			  _.shuffle = function(obj) {
			    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
			    var length = set.length;
			    var shuffled = Array(length);
			    for (var index = 0, rand; index < length; index++) {
			      rand = _.random(0, index);
			      if (rand !== index) shuffled[index] = shuffled[rand];
			      shuffled[rand] = set[index];
			    }
			    return shuffled;
			  };

			  // Sample **n** random values from a collection.
			  // If **n** is not specified, returns a single random element.
			  // The internal `guard` argument allows it to work with `map`.
			  _.sample = function(obj, n, guard) {
			    if (n == null || guard) {
			      if (obj.length !== +obj.length) obj = _.values(obj);
			      return obj[_.random(obj.length - 1)];
			    }
			    return _.shuffle(obj).slice(0, Math.max(0, n));
			  };

			  // Sort the object's values by a criterion produced by an iteratee.
			  _.sortBy = function(obj, iteratee, context) {
			    iteratee = _.iteratee(iteratee, context);
			    return _.pluck(_.map(obj, function(value, index, list) {
			      return {
			        value: value,
			        index: index,
			        criteria: iteratee(value, index, list)
			      };
			    }).sort(function(left, right) {
			      var a = left.criteria;
			      var b = right.criteria;
			      if (a !== b) {
			        if (a > b || a === void 0) return 1;
			        if (a < b || b === void 0) return -1;
			      }
			      return left.index - right.index;
			    }), 'value');
			  };

			  // An internal function used for aggregate "group by" operations.
			  var group = function(behavior) {
			    return function(obj, iteratee, context) {
			      var result = {};
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index) {
			        var key = iteratee(value, index, obj);
			        behavior(result, value, key);
			      });
			      return result;
			    };
			  };

			  // Groups the object's values by a criterion. Pass either a string attribute
			  // to group by, or a function that returns the criterion.
			  _.groupBy = group(function(result, value, key) {
			    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
			  });

			  // Indexes the object's values by a criterion, similar to `groupBy`, but for
			  // when you know that your index values will be unique.
			  _.indexBy = group(function(result, value, key) {
			    result[key] = value;
			  });

			  // Counts instances of an object that group by a certain criterion. Pass
			  // either a string attribute to count by, or a function that returns the
			  // criterion.
			  _.countBy = group(function(result, value, key) {
			    if (_.has(result, key)) result[key]++; else result[key] = 1;
			  });

			  // Use a comparator function to figure out the smallest index at which
			  // an object should be inserted so as to maintain order. Uses binary search.
			  _.sortedIndex = function(array, obj, iteratee, context) {
			    iteratee = _.iteratee(iteratee, context, 1);
			    var value = iteratee(obj);
			    var low = 0, high = array.length;
			    while (low < high) {
			      var mid = low + high >>> 1;
			      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
			    }
			    return low;
			  };

			  // Safely create a real, live array from anything iterable.
			  _.toArray = function(obj) {
			    if (!obj) return [];
			    if (_.isArray(obj)) return slice.call(obj);
			    if (obj.length === +obj.length) return _.map(obj, _.identity);
			    return _.values(obj);
			  };

			  // Return the number of elements in an object.
			  _.size = function(obj) {
			    if (obj == null) return 0;
			    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
			  };

			  // Split a collection into two arrays: one whose elements all satisfy the given
			  // predicate, and one whose elements all do not satisfy the predicate.
			  _.partition = function(obj, predicate, context) {
			    predicate = _.iteratee(predicate, context);
			    var pass = [], fail = [];
			    _.each(obj, function(value, key, obj) {
			      (predicate(value, key, obj) ? pass : fail).push(value);
			    });
			    return [pass, fail];
			  };

			  // Array Functions
			  // ---------------

			  // Get the first element of an array. Passing **n** will return the first N
			  // values in the array. Aliased as `head` and `take`. The **guard** check
			  // allows it to work with `_.map`.
			  _.first = _.head = _.take = function(array, n, guard) {
			    if (array == null) return void 0;
			    if (n == null || guard) return array[0];
			    if (n < 0) return [];
			    return slice.call(array, 0, n);
			  };

			  // Returns everything but the last entry of the array. Especially useful on
			  // the arguments object. Passing **n** will return all the values in
			  // the array, excluding the last N. The **guard** check allows it to work with
			  // `_.map`.
			  _.initial = function(array, n, guard) {
			    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
			  };

			  // Get the last element of an array. Passing **n** will return the last N
			  // values in the array. The **guard** check allows it to work with `_.map`.
			  _.last = function(array, n, guard) {
			    if (array == null) return void 0;
			    if (n == null || guard) return array[array.length - 1];
			    return slice.call(array, Math.max(array.length - n, 0));
			  };

			  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
			  // Especially useful on the arguments object. Passing an **n** will return
			  // the rest N values in the array. The **guard**
			  // check allows it to work with `_.map`.
			  _.rest = _.tail = _.drop = function(array, n, guard) {
			    return slice.call(array, n == null || guard ? 1 : n);
			  };

			  // Trim out all falsy values from an array.
			  _.compact = function(array) {
			    return _.filter(array, _.identity);
			  };

			  // Internal implementation of a recursive `flatten` function.
			  var flatten = function(input, shallow, strict, output) {
			    if (shallow && _.every(input, _.isArray)) {
			      return concat.apply(output, input);
			    }
			    for (var i = 0, length = input.length; i < length; i++) {
			      var value = input[i];
			      if (!_.isArray(value) && !_.isArguments(value)) {
			        if (!strict) output.push(value);
			      } else if (shallow) {
			        push.apply(output, value);
			      } else {
			        flatten(value, shallow, strict, output);
			      }
			    }
			    return output;
			  };

			  // Flatten out an array, either recursively (by default), or just one level.
			  _.flatten = function(array, shallow) {
			    return flatten(array, shallow, false, []);
			  };

			  // Return a version of the array that does not contain the specified value(s).
			  _.without = function(array) {
			    return _.difference(array, slice.call(arguments, 1));
			  };

			  // Produce a duplicate-free version of the array. If the array has already
			  // been sorted, you have the option of using a faster algorithm.
			  // Aliased as `unique`.
			  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
			    if (array == null) return [];
			    if (!_.isBoolean(isSorted)) {
			      context = iteratee;
			      iteratee = isSorted;
			      isSorted = false;
			    }
			    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
			    var result = [];
			    var seen = [];
			    for (var i = 0, length = array.length; i < length; i++) {
			      var value = array[i];
			      if (isSorted) {
			        if (!i || seen !== value) result.push(value);
			        seen = value;
			      } else if (iteratee) {
			        var computed = iteratee(value, i, array);
			        if (_.indexOf(seen, computed) < 0) {
			          seen.push(computed);
			          result.push(value);
			        }
			      } else if (_.indexOf(result, value) < 0) {
			        result.push(value);
			      }
			    }
			    return result;
			  };

			  // Produce an array that contains the union: each distinct element from all of
			  // the passed-in arrays.
			  _.union = function() {
			    return _.uniq(flatten(arguments, true, true, []));
			  };

			  // Produce an array that contains every item shared between all the
			  // passed-in arrays.
			  _.intersection = function(array) {
			    if (array == null) return [];
			    var result = [];
			    var argsLength = arguments.length;
			    for (var i = 0, length = array.length; i < length; i++) {
			      var item = array[i];
			      if (_.contains(result, item)) continue;
			      for (var j = 1; j < argsLength; j++) {
			        if (!_.contains(arguments[j], item)) break;
			      }
			      if (j === argsLength) result.push(item);
			    }
			    return result;
			  };

			  // Take the difference between one array and a number of other arrays.
			  // Only the elements present in just the first array will remain.
			  _.difference = function(array) {
			    var rest = flatten(slice.call(arguments, 1), true, true, []);
			    return _.filter(array, function(value){
			      return !_.contains(rest, value);
			    });
			  };

			  // Zip together multiple lists into a single array -- elements that share
			  // an index go together.
			  _.zip = function(array) {
			    if (array == null) return [];
			    var length = _.max(arguments, 'length').length;
			    var results = Array(length);
			    for (var i = 0; i < length; i++) {
			      results[i] = _.pluck(arguments, i);
			    }
			    return results;
			  };

			  // Converts lists into objects. Pass either a single array of `[key, value]`
			  // pairs, or two parallel arrays of the same length -- one of keys, and one of
			  // the corresponding values.
			  _.object = function(list, values) {
			    if (list == null) return {};
			    var result = {};
			    for (var i = 0, length = list.length; i < length; i++) {
			      if (values) {
			        result[list[i]] = values[i];
			      } else {
			        result[list[i][0]] = list[i][1];
			      }
			    }
			    return result;
			  };

			  // Return the position of the first occurrence of an item in an array,
			  // or -1 if the item is not included in the array.
			  // If the array is large and already in sort order, pass `true`
			  // for **isSorted** to use binary search.
			  _.indexOf = function(array, item, isSorted) {
			    if (array == null) return -1;
			    var i = 0, length = array.length;
			    if (isSorted) {
			      if (typeof isSorted == 'number') {
			        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
			      } else {
			        i = _.sortedIndex(array, item);
			        return array[i] === item ? i : -1;
			      }
			    }
			    for (; i < length; i++) if (array[i] === item) return i;
			    return -1;
			  };

			  _.lastIndexOf = function(array, item, from) {
			    if (array == null) return -1;
			    var idx = array.length;
			    if (typeof from == 'number') {
			      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
			    }
			    while (--idx >= 0) if (array[idx] === item) return idx;
			    return -1;
			  };

			  // Generate an integer Array containing an arithmetic progression. A port of
			  // the native Python `range()` function. See
			  // [the Python documentation](http://docs.python.org/library/functions.html#range).
			  _.range = function(start, stop, step) {
			    if (arguments.length <= 1) {
			      stop = start || 0;
			      start = 0;
			    }
			    step = step || 1;

			    var length = Math.max(Math.ceil((stop - start) / step), 0);
			    var range = Array(length);

			    for (var idx = 0; idx < length; idx++, start += step) {
			      range[idx] = start;
			    }

			    return range;
			  };

			  // Function (ahem) Functions
			  // ------------------

			  // Reusable constructor function for prototype setting.
			  var Ctor = function(){};

			  // Create a function bound to a given object (assigning `this`, and arguments,
			  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
			  // available.
			  _.bind = function(func, context) {
			    var args, bound;
			    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
			    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
			    args = slice.call(arguments, 2);
			    bound = function() {
			      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
			      Ctor.prototype = func.prototype;
			      var self = new Ctor;
			      Ctor.prototype = null;
			      var result = func.apply(self, args.concat(slice.call(arguments)));
			      if (_.isObject(result)) return result;
			      return self;
			    };
			    return bound;
			  };

			  // Partially apply a function by creating a version that has had some of its
			  // arguments pre-filled, without changing its dynamic `this` context. _ acts
			  // as a placeholder, allowing any combination of arguments to be pre-filled.
			  _.partial = function(func) {
			    var boundArgs = slice.call(arguments, 1);
			    return function() {
			      var position = 0;
			      var args = boundArgs.slice();
			      for (var i = 0, length = args.length; i < length; i++) {
			        if (args[i] === _) args[i] = arguments[position++];
			      }
			      while (position < arguments.length) args.push(arguments[position++]);
			      return func.apply(this, args);
			    };
			  };

			  // Bind a number of an object's methods to that object. Remaining arguments
			  // are the method names to be bound. Useful for ensuring that all callbacks
			  // defined on an object belong to it.
			  _.bindAll = function(obj) {
			    var i, length = arguments.length, key;
			    if (length <= 1) throw new Error('bindAll must be passed function names');
			    for (i = 1; i < length; i++) {
			      key = arguments[i];
			      obj[key] = _.bind(obj[key], obj);
			    }
			    return obj;
			  };

			  // Memoize an expensive function by storing its results.
			  _.memoize = function(func, hasher) {
			    var memoize = function(key) {
			      var cache = memoize.cache;
			      var address = hasher ? hasher.apply(this, arguments) : key;
			      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
			      return cache[address];
			    };
			    memoize.cache = {};
			    return memoize;
			  };

			  // Delays a function for the given number of milliseconds, and then calls
			  // it with the arguments supplied.
			  _.delay = function(func, wait) {
			    var args = slice.call(arguments, 2);
			    return setTimeout(function(){
			      return func.apply(null, args);
			    }, wait);
			  };

			  // Defers a function, scheduling it to run after the current call stack has
			  // cleared.
			  _.defer = function(func) {
			    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
			  };

			  // Returns a function, that, when invoked, will only be triggered at most once
			  // during a given window of time. Normally, the throttled function will run
			  // as much as it can, without ever going more than once per `wait` duration;
			  // but if you'd like to disable the execution on the leading edge, pass
			  // `{leading: false}`. To disable execution on the trailing edge, ditto.
			  _.throttle = function(func, wait, options) {
			    var context, args, result;
			    var timeout = null;
			    var previous = 0;
			    if (!options) options = {};
			    var later = function() {
			      previous = options.leading === false ? 0 : _.now();
			      timeout = null;
			      result = func.apply(context, args);
			      if (!timeout) context = args = null;
			    };
			    return function() {
			      var now = _.now();
			      if (!previous && options.leading === false) previous = now;
			      var remaining = wait - (now - previous);
			      context = this;
			      args = arguments;
			      if (remaining <= 0 || remaining > wait) {
			        clearTimeout(timeout);
			        timeout = null;
			        previous = now;
			        result = func.apply(context, args);
			        if (!timeout) context = args = null;
			      } else if (!timeout && options.trailing !== false) {
			        timeout = setTimeout(later, remaining);
			      }
			      return result;
			    };
			  };

			  // Returns a function, that, as long as it continues to be invoked, will not
			  // be triggered. The function will be called after it stops being called for
			  // N milliseconds. If `immediate` is passed, trigger the function on the
			  // leading edge, instead of the trailing.
			  _.debounce = function(func, wait, immediate) {
			    var timeout, args, context, timestamp, result;

			    var later = function() {
			      var last = _.now() - timestamp;

			      if (last < wait && last > 0) {
			        timeout = setTimeout(later, wait - last);
			      } else {
			        timeout = null;
			        if (!immediate) {
			          result = func.apply(context, args);
			          if (!timeout) context = args = null;
			        }
			      }
			    };

			    return function() {
			      context = this;
			      args = arguments;
			      timestamp = _.now();
			      var callNow = immediate && !timeout;
			      if (!timeout) timeout = setTimeout(later, wait);
			      if (callNow) {
			        result = func.apply(context, args);
			        context = args = null;
			      }

			      return result;
			    };
			  };

			  // Returns the first function passed as an argument to the second,
			  // allowing you to adjust arguments, run code before and after, and
			  // conditionally execute the original function.
			  _.wrap = function(func, wrapper) {
			    return _.partial(wrapper, func);
			  };

			  // Returns a negated version of the passed-in predicate.
			  _.negate = function(predicate) {
			    return function() {
			      return !predicate.apply(this, arguments);
			    };
			  };

			  // Returns a function that is the composition of a list of functions, each
			  // consuming the return value of the function that follows.
			  _.compose = function() {
			    var args = arguments;
			    var start = args.length - 1;
			    return function() {
			      var i = start;
			      var result = args[start].apply(this, arguments);
			      while (i--) result = args[i].call(this, result);
			      return result;
			    };
			  };

			  // Returns a function that will only be executed after being called N times.
			  _.after = function(times, func) {
			    return function() {
			      if (--times < 1) {
			        return func.apply(this, arguments);
			      }
			    };
			  };

			  // Returns a function that will only be executed before being called N times.
			  _.before = function(times, func) {
			    var memo;
			    return function() {
			      if (--times > 0) {
			        memo = func.apply(this, arguments);
			      } else {
			        func = null;
			      }
			      return memo;
			    };
			  };

			  // Returns a function that will be executed at most one time, no matter how
			  // often you call it. Useful for lazy initialization.
			  _.once = _.partial(_.before, 2);

			  // Object Functions
			  // ----------------

			  // Retrieve the names of an object's properties.
			  // Delegates to **ECMAScript 5**'s native `Object.keys`
			  _.keys = function(obj) {
			    if (!_.isObject(obj)) return [];
			    if (nativeKeys) return nativeKeys(obj);
			    var keys = [];
			    for (var key in obj) if (_.has(obj, key)) keys.push(key);
			    return keys;
			  };

			  // Retrieve the values of an object's properties.
			  _.values = function(obj) {
			    var keys = _.keys(obj);
			    var length = keys.length;
			    var values = Array(length);
			    for (var i = 0; i < length; i++) {
			      values[i] = obj[keys[i]];
			    }
			    return values;
			  };

			  // Convert an object into a list of `[key, value]` pairs.
			  _.pairs = function(obj) {
			    var keys = _.keys(obj);
			    var length = keys.length;
			    var pairs = Array(length);
			    for (var i = 0; i < length; i++) {
			      pairs[i] = [keys[i], obj[keys[i]]];
			    }
			    return pairs;
			  };

			  // Invert the keys and values of an object. The values must be serializable.
			  _.invert = function(obj) {
			    var result = {};
			    var keys = _.keys(obj);
			    for (var i = 0, length = keys.length; i < length; i++) {
			      result[obj[keys[i]]] = keys[i];
			    }
			    return result;
			  };

			  // Return a sorted list of the function names available on the object.
			  // Aliased as `methods`
			  _.functions = _.methods = function(obj) {
			    var names = [];
			    for (var key in obj) {
			      if (_.isFunction(obj[key])) names.push(key);
			    }
			    return names.sort();
			  };

			  // Extend a given object with all the properties in passed-in object(s).
			  _.extend = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    var source, prop;
			    for (var i = 1, length = arguments.length; i < length; i++) {
			      source = arguments[i];
			      for (prop in source) {
			        if (hasOwnProperty.call(source, prop)) {
			            obj[prop] = source[prop];
			        }
			      }
			    }
			    return obj;
			  };

			  // Return a copy of the object only containing the whitelisted properties.
			  _.pick = function(obj, iteratee, context) {
			    var result = {}, key;
			    if (obj == null) return result;
			    if (_.isFunction(iteratee)) {
			      iteratee = createCallback(iteratee, context);
			      for (key in obj) {
			        var value = obj[key];
			        if (iteratee(value, key, obj)) result[key] = value;
			      }
			    } else {
			      var keys = concat.apply([], slice.call(arguments, 1));
			      obj = new Object(obj);
			      for (var i = 0, length = keys.length; i < length; i++) {
			        key = keys[i];
			        if (key in obj) result[key] = obj[key];
			      }
			    }
			    return result;
			  };

			   // Return a copy of the object without the blacklisted properties.
			  _.omit = function(obj, iteratee, context) {
			    if (_.isFunction(iteratee)) {
			      iteratee = _.negate(iteratee);
			    } else {
			      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
			      iteratee = function(value, key) {
			        return !_.contains(keys, key);
			      };
			    }
			    return _.pick(obj, iteratee, context);
			  };

			  // Fill in a given object with default properties.
			  _.defaults = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    for (var i = 1, length = arguments.length; i < length; i++) {
			      var source = arguments[i];
			      for (var prop in source) {
			        if (obj[prop] === void 0) obj[prop] = source[prop];
			      }
			    }
			    return obj;
			  };

			  // Create a (shallow-cloned) duplicate of an object.
			  _.clone = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
			  };

			  // Invokes interceptor with the obj, and then returns obj.
			  // The primary purpose of this method is to "tap into" a method chain, in
			  // order to perform operations on intermediate results within the chain.
			  _.tap = function(obj, interceptor) {
			    interceptor(obj);
			    return obj;
			  };

			  // Internal recursive comparison function for `isEqual`.
			  var eq = function(a, b, aStack, bStack) {
			    // Identical objects are equal. `0 === -0`, but they aren't identical.
			    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
			    if (a === b) return a !== 0 || 1 / a === 1 / b;
			    // A strict comparison is necessary because `null == undefined`.
			    if (a == null || b == null) return a === b;
			    // Unwrap any wrapped objects.
			    if (a instanceof _) a = a._wrapped;
			    if (b instanceof _) b = b._wrapped;
			    // Compare `[[Class]]` names.
			    var className = toString.call(a);
			    if (className !== toString.call(b)) return false;
			    switch (className) {
			      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
			      case '[object RegExp]':
			      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
			      case '[object String]':
			        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
			        // equivalent to `new String("5")`.
			        return '' + a === '' + b;
			      case '[object Number]':
			        // `NaN`s are equivalent, but non-reflexive.
			        // Object(NaN) is equivalent to NaN
			        if (+a !== +a) return +b !== +b;
			        // An `egal` comparison is performed for other numeric values.
			        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
			      case '[object Date]':
			      case '[object Boolean]':
			        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
			        // millisecond representations. Note that invalid dates with millisecond representations
			        // of `NaN` are not equivalent.
			        return +a === +b;
			    }
			    if (typeof a != 'object' || typeof b != 'object') return false;
			    // Assume equality for cyclic structures. The algorithm for detecting cyclic
			    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
			    var length = aStack.length;
			    while (length--) {
			      // Linear search. Performance is inversely proportional to the number of
			      // unique nested structures.
			      if (aStack[length] === a) return bStack[length] === b;
			    }
			    // Objects with different constructors are not equivalent, but `Object`s
			    // from different frames are.
			    var aCtor = a.constructor, bCtor = b.constructor;
			    if (
			      aCtor !== bCtor &&
			      // Handle Object.create(x) cases
			      'constructor' in a && 'constructor' in b &&
			      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
			        _.isFunction(bCtor) && bCtor instanceof bCtor)
			    ) {
			      return false;
			    }
			    // Add the first object to the stack of traversed objects.
			    aStack.push(a);
			    bStack.push(b);
			    var size, result;
			    // Recursively compare objects and arrays.
			    if (className === '[object Array]') {
			      // Compare array lengths to determine if a deep comparison is necessary.
			      size = a.length;
			      result = size === b.length;
			      if (result) {
			        // Deep compare the contents, ignoring non-numeric properties.
			        while (size--) {
			          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
			        }
			      }
			    } else {
			      // Deep compare objects.
			      var keys = _.keys(a), key;
			      size = keys.length;
			      // Ensure that both objects contain the same number of properties before comparing deep equality.
			      result = _.keys(b).length === size;
			      if (result) {
			        while (size--) {
			          // Deep compare each member
			          key = keys[size];
			          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
			        }
			      }
			    }
			    // Remove the first object from the stack of traversed objects.
			    aStack.pop();
			    bStack.pop();
			    return result;
			  };

			  // Perform a deep comparison to check if two objects are equal.
			  _.isEqual = function(a, b) {
			    return eq(a, b, [], []);
			  };

			  // Is a given array, string, or object empty?
			  // An "empty" object has no enumerable own-properties.
			  _.isEmpty = function(obj) {
			    if (obj == null) return true;
			    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
			    for (var key in obj) if (_.has(obj, key)) return false;
			    return true;
			  };

			  // Is a given value a DOM element?
			  _.isElement = function(obj) {
			    return !!(obj && obj.nodeType === 1);
			  };

			  // Is a given value an array?
			  // Delegates to ECMA5's native Array.isArray
			  _.isArray = nativeIsArray || function(obj) {
			    return toString.call(obj) === '[object Array]';
			  };

			  // Is a given variable an object?
			  _.isObject = function(obj) {
			    var type = typeof obj;
			    return type === 'function' || type === 'object' && !!obj;
			  };

			  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
			  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
			    _['is' + name] = function(obj) {
			      return toString.call(obj) === '[object ' + name + ']';
			    };
			  });

			  // Define a fallback version of the method in browsers (ahem, IE), where
			  // there isn't any inspectable "Arguments" type.
			  if (!_.isArguments(arguments)) {
			    _.isArguments = function(obj) {
			      return _.has(obj, 'callee');
			    };
			  }

			  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
			  if (typeof /./ !== 'function') {
			    _.isFunction = function(obj) {
			      return typeof obj == 'function' || false;
			    };
			  }

			  // Is a given object a finite number?
			  _.isFinite = function(obj) {
			    return isFinite(obj) && !isNaN(parseFloat(obj));
			  };

			  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
			  _.isNaN = function(obj) {
			    return _.isNumber(obj) && obj !== +obj;
			  };

			  // Is a given value a boolean?
			  _.isBoolean = function(obj) {
			    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
			  };

			  // Is a given value equal to null?
			  _.isNull = function(obj) {
			    return obj === null;
			  };

			  // Is a given variable undefined?
			  _.isUndefined = function(obj) {
			    return obj === void 0;
			  };

			  // Shortcut function for checking if an object has a given property directly
			  // on itself (in other words, not on a prototype).
			  _.has = function(obj, key) {
			    return obj != null && hasOwnProperty.call(obj, key);
			  };

			  // Utility Functions
			  // -----------------

			  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
			  // previous owner. Returns a reference to the Underscore object.
			  _.noConflict = function() {
			    root._ = previousUnderscore;
			    return this;
			  };

			  // Keep the identity function around for default iteratees.
			  _.identity = function(value) {
			    return value;
			  };

			  _.constant = function(value) {
			    return function() {
			      return value;
			    };
			  };

			  _.noop = function(){};

			  _.property = function(key) {
			    return function(obj) {
			      return obj[key];
			    };
			  };

			  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
			  _.matches = function(attrs) {
			    var pairs = _.pairs(attrs), length = pairs.length;
			    return function(obj) {
			      if (obj == null) return !length;
			      obj = new Object(obj);
			      for (var i = 0; i < length; i++) {
			        var pair = pairs[i], key = pair[0];
			        if (pair[1] !== obj[key] || !(key in obj)) return false;
			      }
			      return true;
			    };
			  };

			  // Run a function **n** times.
			  _.times = function(n, iteratee, context) {
			    var accum = Array(Math.max(0, n));
			    iteratee = createCallback(iteratee, context, 1);
			    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
			    return accum;
			  };

			  // Return a random integer between min and max (inclusive).
			  _.random = function(min, max) {
			    if (max == null) {
			      max = min;
			      min = 0;
			    }
			    return min + Math.floor(Math.random() * (max - min + 1));
			  };

			  // A (possibly faster) way to get the current timestamp as an integer.
			  _.now = Date.now || function() {
			    return new Date().getTime();
			  };

			   // List of HTML entities for escaping.
			  var escapeMap = {
			    '&': '&amp;',
			    '<': '&lt;',
			    '>': '&gt;',
			    '"': '&quot;',
			    "'": '&#x27;',
			    '`': '&#x60;'
			  };
			  var unescapeMap = _.invert(escapeMap);

			  // Functions for escaping and unescaping strings to/from HTML interpolation.
			  var createEscaper = function(map) {
			    var escaper = function(match) {
			      return map[match];
			    };
			    // Regexes for identifying a key that needs to be escaped
			    var source = '(?:' + _.keys(map).join('|') + ')';
			    var testRegexp = RegExp(source);
			    var replaceRegexp = RegExp(source, 'g');
			    return function(string) {
			      string = string == null ? '' : '' + string;
			      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
			    };
			  };
			  _.escape = createEscaper(escapeMap);
			  _.unescape = createEscaper(unescapeMap);

			  // If the value of the named `property` is a function then invoke it with the
			  // `object` as context; otherwise, return it.
			  _.result = function(object, property) {
			    if (object == null) return void 0;
			    var value = object[property];
			    return _.isFunction(value) ? object[property]() : value;
			  };

			  // Generate a unique integer id (unique within the entire client session).
			  // Useful for temporary DOM ids.
			  var idCounter = 0;
			  _.uniqueId = function(prefix) {
			    var id = ++idCounter + '';
			    return prefix ? prefix + id : id;
			  };

			  // By default, Underscore uses ERB-style template delimiters, change the
			  // following template settings to use alternative delimiters.
			  _.templateSettings = {
			    evaluate    : /<%([\s\S]+?)%>/g,
			    interpolate : /<%=([\s\S]+?)%>/g,
			    escape      : /<%-([\s\S]+?)%>/g
			  };

			  // When customizing `templateSettings`, if you don't want to define an
			  // interpolation, evaluation or escaping regex, we need one that is
			  // guaranteed not to match.
			  var noMatch = /(.)^/;

			  // Certain characters need to be escaped so that they can be put into a
			  // string literal.
			  var escapes = {
			    "'":      "'",
			    '\\':     '\\',
			    '\r':     'r',
			    '\n':     'n',
			    '\u2028': 'u2028',
			    '\u2029': 'u2029'
			  };

			  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

			  var escapeChar = function(match) {
			    return '\\' + escapes[match];
			  };

			  // JavaScript micro-templating, similar to John Resig's implementation.
			  // Underscore templating handles arbitrary delimiters, preserves whitespace,
			  // and correctly escapes quotes within interpolated code.
			  // NB: `oldSettings` only exists for backwards compatibility.
			  _.template = function(text, settings, oldSettings) {
			    if (!settings && oldSettings) settings = oldSettings;
			    settings = _.defaults({}, settings, _.templateSettings);

			    // Combine delimiters into one regular expression via alternation.
			    var matcher = RegExp([
			      (settings.escape || noMatch).source,
			      (settings.interpolate || noMatch).source,
			      (settings.evaluate || noMatch).source
			    ].join('|') + '|$', 'g');

			    // Compile the template source, escaping string literals appropriately.
			    var index = 0;
			    var source = "__p+='";
			    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
			      source += text.slice(index, offset).replace(escaper, escapeChar);
			      index = offset + match.length;

			      if (escape) {
			        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
			      } else if (interpolate) {
			        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
			      } else if (evaluate) {
			        source += "';\n" + evaluate + "\n__p+='";
			      }

			      // Adobe VMs need the match returned to produce the correct offest.
			      return match;
			    });
			    source += "';\n";

			    // If a variable is not specified, place data values in local scope.
			    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

			    source = "var __t,__p='',__j=Array.prototype.join," +
			      "print=function(){__p+=__j.call(arguments,'');};\n" +
			      source + 'return __p;\n';

			    try {
			      var render = new Function(settings.variable || 'obj', '_', source);
			    } catch (e) {
			      e.source = source;
			      throw e;
			    }

			    var template = function(data) {
			      return render.call(this, data, _);
			    };

			    // Provide the compiled source as a convenience for precompilation.
			    var argument = settings.variable || 'obj';
			    template.source = 'function(' + argument + '){\n' + source + '}';

			    return template;
			  };

			  // Add a "chain" function. Start chaining a wrapped Underscore object.
			  _.chain = function(obj) {
			    var instance = _(obj);
			    instance._chain = true;
			    return instance;
			  };

			  // OOP
			  // ---------------
			  // If Underscore is called as a function, it returns a wrapped object that
			  // can be used OO-style. This wrapper holds altered versions of all the
			  // underscore functions. Wrapped objects may be chained.

			  // Helper function to continue chaining intermediate results.
			  var result = function(obj) {
			    return this._chain ? _(obj).chain() : obj;
			  };

			  // Add your own custom functions to the Underscore object.
			  _.mixin = function(obj) {
			    _.each(_.functions(obj), function(name) {
			      var func = _[name] = obj[name];
			      _.prototype[name] = function() {
			        var args = [this._wrapped];
			        push.apply(args, arguments);
			        return result.call(this, func.apply(_, args));
			      };
			    });
			  };

			  // Add all of the Underscore functions to the wrapper object.
			  _.mixin(_);

			  // Add all mutator Array functions to the wrapper.
			  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
			    var method = ArrayProto[name];
			    _.prototype[name] = function() {
			      var obj = this._wrapped;
			      method.apply(obj, arguments);
			      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
			      return result.call(this, obj);
			    };
			  });

			  // Add all accessor Array functions to the wrapper.
			  _.each(['concat', 'join', 'slice'], function(name) {
			    var method = ArrayProto[name];
			    _.prototype[name] = function() {
			      return result.call(this, method.apply(this._wrapped, arguments));
			    };
			  });

			  // Extracts the result from a wrapped and chained object.
			  _.prototype.value = function() {
			    return this._wrapped;
			  };

			  // AMD registration happens at the end for compatibility with AMD loaders
			  // that may not enforce next-turn semantics on modules. Even though general
			  // practice for AMD registration is to be anonymous, underscore registers
			  // as a named module because, like jQuery, it is a base library that is
			  // popular enough to be bundled in a third party lib, but not be part of
			  // an AMD load request. Those cases could generate an error when an
			  // anonymous define() is called outside of a loader request.
			  if (typeof define === 'function' && define.amd) {
			    define('underscore', [], function() {
			      return _;
			    });
			  }
			}.call(this));
		}
	}
})("missile_dodge/src/index");
