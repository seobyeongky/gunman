this["global"] = this;
// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	var resolve, getRequire, require, notFoundError, findFile
	  , extensions = {".js":[".coffee"],".json":[],".css":[],".html":[]};
	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullpath, state) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
			} else {
				tree.push(scope);
				scope = scope[dir];
			}
			if (!scope) throw notFoundError(fullpath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullpath, 1);
			}
			return resolve(scope, tree, 'index', fullpath, 2);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullpath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports };
		fn.call(exports, exports, module, getRequire(scope, tree));
		return module.exports;
	};
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) throw notFoundError(fullpath);
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullpath, state);
	};
	getRequire = function (scope, tree) {
		return function (path) { return require(scope, [].concat(tree), path); };
	};
	return getRequire(modules, []);
})({
	"dust2": {
		"src": {
			"bg.coffee": function (exports, module, require) {
				var make_sprite;

				make_sprite = require('./utils/sprite').make_sprite;

				module.exports = {
				  make_bg: function() {
				    var sp;
				    sp = make_sprite("bg.jpg", UI.width, UI.height);
				    return sp;
				  }
				};
			},
			"consts.coffee": function (exports, module, require) {
				module.exports = {
				  STATE_READY: 0,
				  STATE_PLAY: 1,
				  STATE_RESULT: 2,
				  BG_KIND: 3,
				  SEA_SEVERTY_LEVELS: 4,
				  MAX_HP: 100,
				  FRAME_RATE: 60,
				  MAX_NR_PLAYER: 4,
				  PADDING: 0.05 * UI.height,
				  SMALL_PADDING: 0.025 * UI.height,
				  TXT_HEIGHT: 0.03 * UI.height
				};
			},
			"index.coffee": function (exports, module, require) {
				var FIRST_STATE, MAX_PLAYER, STATE_PLAY, STATE_RESULT, current_stage, env, next_scene, scene, scenes, _ref,
				  __slice = [].slice;

				_ref = require('./consts'), STATE_PLAY = _ref.STATE_PLAY, STATE_RESULT = _ref.STATE_RESULT, MAX_PLAYER = _ref.MAX_PLAYER;

				require('./utils/register');

				FIRST_STATE = STATE_PLAY;

				scenes = {};

				env = {
				  state: FIRST_STATE,
				  players: Player.all()
				};

				scenes[STATE_PLAY] = require('./play');

				scenes[STATE_RESULT] = require('./result');

				current_stage = FIRST_STATE;

				scene = null;

				next_scene = function() {
				  return scene = scenes[current_stage](env);
				};

				next_scene();

				onPlayerInput(function() {
				  var args;
				  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				  scene.on_player_input.apply(scene, args);
				  if (current_stage !== env.state) {
				    current_stage = env.state;
				    return next_scene();
				  }
				});

				onFrameMove(function() {
				  var args;
				  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
				  scene.on_frame_move.apply(scene, args);
				  if (current_stage !== env.state) {
				    current_stage = env.state;
				    next_scene();
				  }
				  return env.tick++;
				});
			},
			"libs": {
				"RNG.js": function (exports, module, require) {
					(function () {
					    /**
					     * Seedable random number generator functions.
					     * @version 1.0.0
					     * @license Public Domain
					     *
					     * @example
					     * var rng = new RNG('Example');
					     * rng.random(40, 50);  // =>  42
					     * rng.uniform();       // =>  0.7972798995050903
					     * rng.normal();        // => -0.6698504543216376
					     * rng.exponential();   // =>  1.0547367609131555
					     * rng.poisson(4);      // =>  2
					     * rng.gamma(4);        // =>  2.781724687386858
					     */
					
					    /**
					     * @param {String} seed A string to seed the generator.
					     * @constructor
					     */
					    function RC4(seed) {
					        this.s = new Array(256);
					        this.i = 0;
					        this.j = 0;
					        for (var i = 0; i < 256; i++) {
					            this.s[i] = i;
					        }
					        if (seed) {
					            this.mix(seed);
					        }
					    }
					
					    /**
					     * Get the underlying bytes of a string.
					     * @param {string} string
					     * @returns {Array} An array of bytes
					     */
					    RC4.getStringBytes = function(string) {
					        var output = [];
					        for (var i = 0; i < string.length; i++) {
					            var c = string.charCodeAt(i);
					            var bytes = [];
					            do {
					                bytes.push(c & 0xFF);
					                c = c >> 8;
					            } while (c > 0);
					            output = output.concat(bytes.reverse());
					        }
					        return output;
					    };
					
					    RC4.prototype._swap = function(i, j) {
					        var tmp = this.s[i];
					        this.s[i] = this.s[j];
					        this.s[j] = tmp;
					    };
					
					    /**
					     * Mix additional entropy into this generator.
					     * @param {String} seed
					     */
					    RC4.prototype.mix = function(seed) {
					        var input = RC4.getStringBytes(seed);
					        var j = 0;
					        for (var i = 0; i < this.s.length; i++) {
					            j += this.s[i] + input[i % input.length];
					            j %= 256;
					            this._swap(i, j);
					        }
					    };
					
					    /**
					     * @returns {number} The next byte of output from the generator.
					     */
					    RC4.prototype.next = function() {
					        this.i = (this.i + 1) % 256;
					        this.j = (this.j + this.s[this.i]) % 256;
					        this._swap(this.i, this.j);
					        return this.s[(this.s[this.i] + this.s[this.j]) % 256];
					    };
					
					    /**
					     * Create a new random number generator with optional seed. If the
					     * provided seed is a function (i.e. Math.random) it will be used as
					     * the uniform number generator.
					     * @param seed An arbitrary object used to seed the generator.
					     * @constructor
					     */
					    function RNG(seed) {
					        if (seed == null) {
					            seed = (Math.random() + Date.now()).toString();
					        } else if (typeof seed === "function") {
					            // Use it as a uniform number generator
					            this.uniform = seed;
					            this.nextByte = function() {
					                return ~~(this.uniform() * 256);
					            };
					            seed = null;
					        } else if (Object.prototype.toString.call(seed) !== "[object String]") {
					            seed = JSON.stringify(seed);
					        }
					        this._normal = null;
					        if (seed) {
					            this._state = new RC4(seed);
					        } else {
					            this._state = null;
					        }
					    }
					
					    /**
					     * @returns {number} Uniform random number between 0 and 255.
					     */
					    RNG.prototype.nextByte = function() {
					        return this._state.next();
					    };
					
					    /**
					     * @returns {number} Uniform random number between 0 and 1.
					     */
					    RNG.prototype.uniform = function() {
					        var BYTES = 7; // 56 bits to make a 53-bit double
					        var output = 0;
					        for (var i = 0; i < BYTES; i++) {
					            output *= 256;
					            output += this.nextByte();
					        }
					        return output / (Math.pow(2, BYTES * 8) - 1);
					    };
					
					    /**
					     * Produce a random integer within [n, m).
					     * @param {number} [n=0]
					     * @param {number} m
					     *
					     */
					    RNG.prototype.random = function(n, m) {
					        if (n == null) {
					            return this.uniform();
					        } else if (m == null) {
					            m = n;
					            n = 0;
					        }
					        return n + Math.floor(this.uniform() * (m - n));
					    };
					
					    /**
					     * Generates numbers using this.uniform() with the Box-Muller transform.
					     * @returns {number} Normally-distributed random number of mean 0, variance 1.
					     */
					    RNG.prototype.normal = function() {
					        if (this._normal !== null) {
					            var n = this._normal;
					            this._normal = null;
					            return n;
					        } else {
					            var x = this.uniform() || Math.pow(2, -53); // can't be exactly 0
					            var y = this.uniform();
					            this._normal = Math.sqrt(-2 * Math.log(x)) * Math.sin(2 * Math.PI * y);
					            return Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);
					        }
					    };
					
					    /**
					     * Generates numbers using this.uniform().
					     * @returns {number} Number from the exponential distribution, lambda = 1.
					     */
					    RNG.prototype.exponential = function() {
					        return -Math.log(this.uniform() || Math.pow(2, -53));
					    };
					
					    /**
					     * Generates numbers using this.uniform() and Knuth's method.
					     * @param {number} [mean=1]
					     * @returns {number} Number from the Poisson distribution.
					     */
					    RNG.prototype.poisson = function(mean) {
					        var L = Math.exp(-(mean || 1));
					        var k = 0, p = 1;
					        do {
					            k++;
					            p *= this.uniform();
					        } while (p > L);
					        return k - 1;
					    };
					
					    /**
					     * Generates numbers using this.uniform(), this.normal(),
					     * this.exponential(), and the Marsaglia-Tsang method.
					     * @param {number} a
					     * @returns {number} Number from the gamma distribution.
					     */
					    RNG.prototype.gamma = function(a) {
					        var d = (a < 1 ? 1 + a : a) - 1 / 3;
					        var c = 1 / Math.sqrt(9 * d);
					        do {
					            do {
					                var x = this.normal();
					                var v = Math.pow(c * x + 1, 3);
					            } while (v <= 0);
					            var u = this.uniform();
					            var x2 = Math.pow(x, 2);
					        } while (u >= 1 - 0.0331 * x2 * x2 &&
					                 Math.log(u) >= 0.5 * x2 + d * (1 - v + Math.log(v)));
					        if (a < 1) {
					            return d * v * Math.exp(this.exponential() / -a);
					        } else {
					            return d * v;
					        }
					    };
					
					    /**
					     * Accepts a dice rolling notation string and returns a generator
					     * function for that distribution. The parser is quite flexible.
					     * @param {string} expr A dice-rolling, expression i.e. '2d6+10'.
					     * @param {RNG} rng An optional RNG object.
					     * @returns {Function}
					     */
					    RNG.roller = function(expr, rng) {
					        var parts = expr.split(/(\d+)?d(\d+)([+-]\d+)?/).slice(1);
					        var dice = parseFloat(parts[0]) || 1;
					        var sides = parseFloat(parts[1]);
					        var mod = parseFloat(parts[2]) || 0;
					        rng = rng || new RNG();
					        return function() {
					            var total = dice + mod;
					            for (var i = 0; i < dice; i++) {
					                total += rng.random(sides);
					            }
					            return total;
					        };
					    };
					
					    /* Provide a pre-made generator instance. */
					    RNG.$ = new RNG();
					    
					    module.exports = RNG;
					})()
				}
			},
			"minimap.coffee": function (exports, module, require) {
				module.exports = {
				  make_minimap: function() {
				    var H, padding, sp, tex;
				    sp = new Sprite;
				    sp.originX = 0;
				    sp.originY = 0;
				    tex = new Texture;
				    tex.loadFromFile("textures/minimap.jpg");
				    sp.texture = tex;
				    H = 0.6 * UI.height;
				    padding = 0.05 * UI.height;
				    sp.scaleX = sp.scaleY = H / tex.height;
				    sp.x = padding;
				    sp.y = padding;
				    return sp;
				  }
				};
			},
			"play.coffee": function (exports, module, require) {
				var BG_KIND, FRAME_RATE, INPUT_CHAT_MESSAGE, MAX_HP, RANDOM, SEA_SEVERTY_LEVELS, STATE_RESULT, Scheduler, main_key_color, make_bg, make_minimap, make_selbox, make_statbox, sub_key_color, textures, the_seed, _, _ref,
				  __slice = [].slice;

				_ = require('underscore');

				INPUT_CHAT_MESSAGE = require('./system/consts').INPUT_CHAT_MESSAGE;

				_ref = require('./consts'), STATE_RESULT = _ref.STATE_RESULT, BG_KIND = _ref.BG_KIND, SEA_SEVERTY_LEVELS = _ref.SEA_SEVERTY_LEVELS, MAX_HP = _ref.MAX_HP, FRAME_RATE = _ref.FRAME_RATE;

				Scheduler = require('./scheduler').Scheduler;

				make_bg = require('./bg').make_bg;

				make_minimap = require('./minimap').make_minimap;

				make_statbox = require('./statbox').make_statbox;

				make_selbox = require('./selbox').make_selbox;

				textures = {};

				main_key_color = function(index) {
				  switch (index % 3) {
				    case 0:
				      return {
				        r: 0,
				        g: 0,
				        b: 0,
				        a: 255
				      };
				    case 1:
				      return {
				        r: 50,
				        g: 50,
				        b: 50,
				        a: 255
				      };
				    case 2:
				      return {
				        r: 255,
				        g: 255,
				        b: 240,
				        a: 255
				      };
				  }
				};

				sub_key_color = function(index) {
				  switch (index % 3) {
				    case 0:
				      return {
				        r: 255,
				        g: 255,
				        b: 255,
				        a: 255
				      };
				    case 1:
				      return {
				        r: 180,
				        g: 180,
				        b: 170,
				        a: 255
				      };
				    case 2:
				      return {
				        r: 190,
				        g: 190,
				        b: 180,
				        a: 255
				      };
				  }
				};

				the_seed = 123;

				RANDOM = (require('./random'))(the_seed);

				module.exports = function(env) {
				  var bg, handle_chat, i, j, minimap, player, players, render, scheduler, selbox, statboxes, update, update_turn, _i, _len;
				  players = env.players;
				  scheduler = new Scheduler;
				  bg = make_bg();
				  minimap = make_minimap();
				  statboxes = [0, 1, 2, 3].map(make_statbox);
				  selbox = make_selbox();
				  j = 1;
				  for (i = _i = 0, _len = players.length; _i < _len; i = ++_i) {
				    player = players[i];
				    if (i >= 4) {
				      break;
				    }
				    player.hp = MAX_HP;
				    player.turn_used = false;
				    if (player.id === Player.me().id) {
				      player.statbox = statboxes[0];
				      player.visible = true;
				    } else {
				      player.statbox = statboxes[j++];
				      player.visible = false;
				    }
				    player.statbox.set_player(player);
				  }
				  update_turn = function() {
				    var turn_player;
				    turn_player = env.turn_player = _.find(players, function(player) {
				      return player.turn_used === false;
				    });
				    turn_player.turn_used = true;
				    return print("" + turn_player.name + "님의 턴입니다.");
				  };
				  scheduler.add(update_turn, 0.5);
				  handle_chat = function() {};
				  update = function() {
				    return scheduler.tick();
				  };
				  render = function() {
				    var statbox, _j, _len1;
				    UI.draw(bg);
				    UI.draw(minimap);
				    for (_j = 0, _len1 = statboxes.length; _j < _len1; _j++) {
				      statbox = statboxes[_j];
				      statbox.render();
				    }
				    return selbox.render();
				  };
				  return {
				    on_frame_move: function() {
				      update();
				      render();
				    },
				    on_player_input: function() {
				      var args, pid, type;
				      pid = arguments[0], type = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
				      if (type === INPUT_CHAT_MESSAGE) {
				        return handle_chat(pid, args[0]);
				      }
				    }
				  };
				};
			},
			"random.coffee": function (exports, module, require) {
				var RNG;

				RNG = require('./libs/RNG');

				module.exports = function(seed) {
				  var rng;
				  rng = new RNG(seed);
				  return {
				    number: function(N) {
				      return rng.random(0, N);
				    },
				    shuffle: function(obj) {
				      var index, shuffled;
				      index = 0;
				      shuffled = [];
				      obj.forEach(function(value) {
				        var rand;
				        rand = rng.random(0, ++index);
				        shuffled[index - 1] = shuffled[rand];
				        return shuffled[rand] = value;
				      });
				      return shuffled;
				    }
				  };
				};
			},
			"result.coffee": function (exports, module, require) {
				var STATE_READY, Scheduler, textures, _;

				_ = require('underscore');

				STATE_READY = require('./consts').STATE_READY;

				Scheduler = require('./scheduler').Scheduler;

				textures = {};

				['gameover', 'gameclear', 'stageclear'].forEach(function(name) {
				  var t;
				  t = new Texture;
				  t.loadFromFile("textures/bg_" + name + ".png");
				  return textures["bg_" + name] = t;
				});

				module.exports = function(env) {
				  var all_cleared, bg, make_bg, make_result_text, players, result_text, scheduler, stage_cleared, stats;
				  players = env.players, stats = env.stats, stage_cleared = env.stage_cleared;
				  scheduler = new Scheduler;
				  result_text = null;
				  bg = null;
				  all_cleared = function() {
				    return env.lv === stages.length - 1;
				  };
				  make_result_text = function() {
				    var sorted, text, wrapped;
				    text = new Text;
				    text.characterSize = 25;
				    text.string = "결과!";
				    text.x = 0.3 * UI.width;
				    text.y = 0.3 * UI.height;
				    wrapped = stats.map(function(a, i) {
				      return _.extend({
				        pid: i
				      }, a);
				    });
				    sorted = _.sortBy(wrapped, function(a) {
				      return a.nr_destroy;
				    });
				    sorted.reverse();
				    sorted.forEach(function(a, i) {
				      var p;
				      p = players[a.pid];
				      return scheduler.add(function() {
				        text.string += "\n";
				        return text.string += "" + p.name + " : " + a.nr_destroy + "개 파괴!";
				      }, i + 2);
				    });
				    return text;
				  };
				  result_text = make_result_text();
				  make_bg = function() {
				    var s, t;
				    t = null;
				    if (stage_cleared) {
				      if (all_cleared()) {
				        t = textures.bg_gameclear;
				      } else {
				        t = textures.bg_stageclear;
				      }
				    } else {
				      t = textures.bg_gameover;
				    }
				    s = new Sprite;
				    s.texture = t;
				    s.x = 0;
				    s.y = 0;
				    s.originX = 0;
				    s.originY = 0;
				    s.scaleX = UI.width / t.width;
				    s.scaleY = UI.height / t.height;
				    return s;
				  };
				  bg = make_bg();
				  scheduler.add(function() {
				    if (all_cleared()) {
				      result_text.string += "\n축하합니다. 모든 스테이지를 클리어하였습니다!";
				      return;
				    }
				    if (stage_cleared) {
				      env.lv++;
				    } else {
				      env.lv = 0;
				    }
				    return env.state = STATE_READY;
				  }, players.length + 6);
				  return {
				    on_frame_move: function() {
				      scheduler.tick();
				      UI.draw(bg);
				      return UI.draw(result_text);
				    },
				    on_player_input: function() {}
				  };
				};
			},
			"scheduler.coffee": function (exports, module, require) {
				var FRAME_RATE, STATE_READY, Scheduler, _ref;

				_ref = require('./consts'), FRAME_RATE = _ref.FRAME_RATE, STATE_READY = _ref.STATE_READY;

				Scheduler = (function() {
				  function Scheduler() {
				    this.schedule = {};
				    this.current_tick = 0;
				  }

				  Scheduler.prototype.add = function(fn, seconds) {
				    var after, queue, _base, _name;
				    after = (seconds * FRAME_RATE) | 0;
				    queue = (_base = this.schedule)[_name = this.current_tick + after] != null ? (_base = this.schedule)[_name = this.current_tick + after] : _base[_name] = [];
				    return queue.push(fn);
				  };

				  Scheduler.prototype.next_tick = function(fn) {
				    var queue, _base, _name;
				    queue = (_base = this.schedule)[_name = this.current_tick + 1] != null ? (_base = this.schedule)[_name = this.current_tick + 1] : _base[_name] = [];
				    return queue.push(fn);
				  };

				  Scheduler.prototype.tick = function() {
				    var fn, list, _i, _len, _ref1;
				    while ((_ref1 = this.schedule[this.current_tick]) != null ? _ref1.length : void 0) {
				      list = this.schedule[this.current_tick];
				      delete this.schedule[this.current_tick];
				      for (_i = 0, _len = list.length; _i < _len; _i++) {
				        fn = list[_i];
				        fn();
				      }
				    }
				    return this.current_tick++;
				  };

				  return Scheduler;

				})();

				module.exports = {
				  Scheduler: Scheduler
				};
			},
			"selbox.coffee": function (exports, module, require) {
				var PADDING, SMALL_PADDING, TXT_HEIGHT, make_sprite, _ref;

				_ref = require('./consts'), PADDING = _ref.PADDING, SMALL_PADDING = _ref.SMALL_PADDING, TXT_HEIGHT = _ref.TXT_HEIGHT;

				make_sprite = require('./utils/sprite').make_sprite;

				module.exports = {
				  make_selbox: function() {
				    var bg, make_txt, txtlist;
				    bg = make_sprite("frame0.png", 0.4 * UI.width, 0.2 * UI.height);
				    bg.x = PADDING;
				    bg.y = UI.height - PADDING - bg.scaleY * bg.texture.height;
				    make_txt = function(i) {
				      var txt;
				      txt = new Text;
				      txt.color = rgba(255, 255, 255, 255);
				      txt.characterSize = TXT_HEIGHT;
				      txt.x = bg.x + SMALL_PADDING;
				      txt.y = bg.y + SMALL_PADDING + i * (txt.characterSize + SMALL_PADDING);
				      txt.string = "" + (i + 1) + ". 선택지 " + (i + 1) + "!!";
				      return txt;
				    };
				    txtlist = [0, 1, 2].map(make_txt);
				    return {
				      set_player: function() {},
				      render: function() {
				        UI.draw(bg);
				        return txtlist.forEach(function(txt) {
				          return UI.draw(txt);
				        });
				      }
				    };
				  }
				};
			},
			"statbox.coffee": function (exports, module, require) {
				var PADDING, SMALL_PADDING, TXT_HEIGHT, make_sprite, _ref;

				_ref = require('./consts'), PADDING = _ref.PADDING, SMALL_PADDING = _ref.SMALL_PADDING, TXT_HEIGHT = _ref.TXT_HEIGHT;

				make_sprite = require('./utils/sprite').make_sprite;

				module.exports = {
				  make_statbox: function(i) {
				    var AX, H, W, X, Y, avatar, bg, bloody, hp_txt, name_txt, player;
				    player = null;
				    W = 0.4 * UI.width;
				    H = 0.2 * UI.height;
				    X = UI.width - W - PADDING;
				    Y = PADDING + i * (SMALL_PADDING + 0.2 * UI.height);
				    bg = make_sprite("frame0.png", W, H);
				    bg.x = X;
				    bg.y = Y;
				    AX = X + SMALL_PADDING;
				    avatar = make_sprite("avatar" + i + ".png", null, H - 2 * SMALL_PADDING);
				    avatar.x = AX;
				    avatar.y = Y + SMALL_PADDING;
				    AX += avatar.scaleX * avatar.texture.width;
				    name_txt = new Text;
				    name_txt.x = AX + PADDING;
				    name_txt.y = Y + SMALL_PADDING;
				    name_txt.characterSize = TXT_HEIGHT;
				    hp_txt = new Text;
				    hp_txt.x = AX + PADDING;
				    hp_txt.y = Y + SMALL_PADDING + TXT_HEIGHT + SMALL_PADDING;
				    hp_txt.characterSize = TXT_HEIGHT;
				    hp_txt.color = rgba(255, 255, 255, 255);
				    bloody = make_sprite("bloody.png", W, H);
				    bloody.x = X;
				    bloody.y = Y;
				    return {
				      set_player: function(player_) {
				        player = player_;
				        name_txt.string = player.name;
				        if (player === Player.me().id) {
				          return name_txt.color = rgba(0, 255, 0, 255);
				        } else {
				          return name_txt.color = rgba(255, 0, 0, 255);
				        }
				      },
				      render: function() {
				        if (player == null) {
				          return;
				        }
				        UI.draw(bg);
				        hp_txt.string = "HP : " + player.hp;
				        if (player.visible) {
				          UI.draw(avatar);
				          UI.draw(name_txt);
				          return UI.draw(hp_txt);
				        }
				      }
				    };
				  }
				};
			},
			"system": {
				"consts.js": function (exports, module, require) {
					out = {}
					
					// inputs
					out.INPUT_LEFT_MOUSE_DOWN = 0
					out.INPUT_LEFT_MOUSE_UP = 1
					out.INPUT_RIGHT_MOUSE_DOWN = 2
					out.INPUT_RIGHT_MOUSE_UP = 3
					out.INPUT_MOUSE_MOVE = 4
					out.INPUT_KEY_DOWN = 5
					out.INPUT_KEY_UP = 6
					out.INPUT_CHAT_MESSAGE = 7
					
					module.exports = out
				}
			},
			"utils": {
				"register.coffee": function (exports, module, require) {
					global.rgb = function(r, g, b) {
					  return {
					    r: r,
					    g: g,
					    b: b
					  };
					};

					global.rgba = function(r, g, b, a) {
					  return {
					    r: r,
					    g: g,
					    b: b,
					    a: a
					  };
					};
				},
				"sprite.coffee": function (exports, module, require) {
					module.exports = {
					  make_sprite: function(texfile, width, height) {
					    var sp, tex;
					    sp = new Sprite;
					    sp.originX = 0;
					    sp.originY = 0;
					    tex = new Texture;
					    tex.loadFromFile("textures/" + texfile);
					    sp.texture = tex;
					    if ((width != null) && (height != null)) {
					      sp.scaleX = width / tex.width;
					      sp.scaleY = height / tex.height;
					    } else if (width != null) {
					      sp.scaleX = sp.scaleY = width / tex.width;
					    } else if (height != null) {
					      sp.scaleX = sp.scaleY = height / tex.height;
					    }
					    return sp;
					  }
					};
				}
			}
		}
	},
	"underscore": {
		":mainpath:": "underscore.js",
		"underscore.js": function (exports, module, require) {
			//     Underscore.js 1.7.0
			//     http://underscorejs.org
			//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
			//     Underscore may be freely distributed under the MIT license.

			(function() {

			  // Baseline setup
			  // --------------

			  // Establish the root object, `window` in the browser, or `exports` on the server.
			  var root = this;

			  // Save the previous value of the `_` variable.
			  var previousUnderscore = root._;

			  // Save bytes in the minified (but not gzipped) version:
			  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

			  // Create quick reference variables for speed access to core prototypes.
			  var
			    push             = ArrayProto.push,
			    slice            = ArrayProto.slice,
			    concat           = ArrayProto.concat,
			    toString         = ObjProto.toString,
			    hasOwnProperty   = ObjProto.hasOwnProperty;

			  // All **ECMAScript 5** native function implementations that we hope to use
			  // are declared here.
			  var
			    nativeIsArray      = Array.isArray,
			    nativeKeys         = Object.keys,
			    nativeBind         = FuncProto.bind;

			  // Create a safe reference to the Underscore object for use below.
			  var _ = function(obj) {
			    if (obj instanceof _) return obj;
			    if (!(this instanceof _)) return new _(obj);
			    this._wrapped = obj;
			  };

			  // Export the Underscore object for **Node.js**, with
			  // backwards-compatibility for the old `require()` API. If we're in
			  // the browser, add `_` as a global object.
			  if (typeof exports !== 'undefined') {
			    if (typeof module !== 'undefined' && module.exports) {
			      exports = module.exports = _;
			    }
			    exports._ = _;
			  } else {
			    root._ = _;
			  }

			  // Current version.
			  _.VERSION = '1.7.0';

			  // Internal function that returns an efficient (for current engines) version
			  // of the passed-in callback, to be repeatedly applied in other Underscore
			  // functions.
			  var createCallback = function(func, context, argCount) {
			    if (context === void 0) return func;
			    switch (argCount == null ? 3 : argCount) {
			      case 1: return function(value) {
			        return func.call(context, value);
			      };
			      case 2: return function(value, other) {
			        return func.call(context, value, other);
			      };
			      case 3: return function(value, index, collection) {
			        return func.call(context, value, index, collection);
			      };
			      case 4: return function(accumulator, value, index, collection) {
			        return func.call(context, accumulator, value, index, collection);
			      };
			    }
			    return function() {
			      return func.apply(context, arguments);
			    };
			  };

			  // A mostly-internal function to generate callbacks that can be applied
			  // to each element in a collection, returning the desired result — either
			  // identity, an arbitrary callback, a property matcher, or a property accessor.
			  _.iteratee = function(value, context, argCount) {
			    if (value == null) return _.identity;
			    if (_.isFunction(value)) return createCallback(value, context, argCount);
			    if (_.isObject(value)) return _.matches(value);
			    return _.property(value);
			  };

			  // Collection Functions
			  // --------------------

			  // The cornerstone, an `each` implementation, aka `forEach`.
			  // Handles raw objects in addition to array-likes. Treats all
			  // sparse array-likes as if they were dense.
			  _.each = _.forEach = function(obj, iteratee, context) {
			    if (obj == null) return obj;
			    iteratee = createCallback(iteratee, context);
			    var i, length = obj.length;
			    if (length === +length) {
			      for (i = 0; i < length; i++) {
			        iteratee(obj[i], i, obj);
			      }
			    } else {
			      var keys = _.keys(obj);
			      for (i = 0, length = keys.length; i < length; i++) {
			        iteratee(obj[keys[i]], keys[i], obj);
			      }
			    }
			    return obj;
			  };

			  // Return the results of applying the iteratee to each element.
			  _.map = _.collect = function(obj, iteratee, context) {
			    if (obj == null) return [];
			    iteratee = _.iteratee(iteratee, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        results = Array(length),
			        currentKey;
			    for (var index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      results[index] = iteratee(obj[currentKey], currentKey, obj);
			    }
			    return results;
			  };

			  var reduceError = 'Reduce of empty array with no initial value';

			  // **Reduce** builds up a single result from a list of values, aka `inject`,
			  // or `foldl`.
			  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
			    if (obj == null) obj = [];
			    iteratee = createCallback(iteratee, context, 4);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index = 0, currentKey;
			    if (arguments.length < 3) {
			      if (!length) throw new TypeError(reduceError);
			      memo = obj[keys ? keys[index++] : index++];
			    }
			    for (; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      memo = iteratee(memo, obj[currentKey], currentKey, obj);
			    }
			    return memo;
			  };

			  // The right-associative version of reduce, also known as `foldr`.
			  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
			    if (obj == null) obj = [];
			    iteratee = createCallback(iteratee, context, 4);
			    var keys = obj.length !== + obj.length && _.keys(obj),
			        index = (keys || obj).length,
			        currentKey;
			    if (arguments.length < 3) {
			      if (!index) throw new TypeError(reduceError);
			      memo = obj[keys ? keys[--index] : --index];
			    }
			    while (index--) {
			      currentKey = keys ? keys[index] : index;
			      memo = iteratee(memo, obj[currentKey], currentKey, obj);
			    }
			    return memo;
			  };

			  // Return the first value which passes a truth test. Aliased as `detect`.
			  _.find = _.detect = function(obj, predicate, context) {
			    var result;
			    predicate = _.iteratee(predicate, context);
			    _.some(obj, function(value, index, list) {
			      if (predicate(value, index, list)) {
			        result = value;
			        return true;
			      }
			    });
			    return result;
			  };

			  // Return all the elements that pass a truth test.
			  // Aliased as `select`.
			  _.filter = _.select = function(obj, predicate, context) {
			    var results = [];
			    if (obj == null) return results;
			    predicate = _.iteratee(predicate, context);
			    _.each(obj, function(value, index, list) {
			      if (predicate(value, index, list)) results.push(value);
			    });
			    return results;
			  };

			  // Return all the elements for which a truth test fails.
			  _.reject = function(obj, predicate, context) {
			    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
			  };

			  // Determine whether all of the elements match a truth test.
			  // Aliased as `all`.
			  _.every = _.all = function(obj, predicate, context) {
			    if (obj == null) return true;
			    predicate = _.iteratee(predicate, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index, currentKey;
			    for (index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      if (!predicate(obj[currentKey], currentKey, obj)) return false;
			    }
			    return true;
			  };

			  // Determine if at least one element in the object matches a truth test.
			  // Aliased as `any`.
			  _.some = _.any = function(obj, predicate, context) {
			    if (obj == null) return false;
			    predicate = _.iteratee(predicate, context);
			    var keys = obj.length !== +obj.length && _.keys(obj),
			        length = (keys || obj).length,
			        index, currentKey;
			    for (index = 0; index < length; index++) {
			      currentKey = keys ? keys[index] : index;
			      if (predicate(obj[currentKey], currentKey, obj)) return true;
			    }
			    return false;
			  };

			  // Determine if the array or object contains a given value (using `===`).
			  // Aliased as `include`.
			  _.contains = _.include = function(obj, target) {
			    if (obj == null) return false;
			    if (obj.length !== +obj.length) obj = _.values(obj);
			    return _.indexOf(obj, target) >= 0;
			  };

			  // Invoke a method (with arguments) on every item in a collection.
			  _.invoke = function(obj, method) {
			    var args = slice.call(arguments, 2);
			    var isFunc = _.isFunction(method);
			    return _.map(obj, function(value) {
			      return (isFunc ? method : value[method]).apply(value, args);
			    });
			  };

			  // Convenience version of a common use case of `map`: fetching a property.
			  _.pluck = function(obj, key) {
			    return _.map(obj, _.property(key));
			  };

			  // Convenience version of a common use case of `filter`: selecting only objects
			  // containing specific `key:value` pairs.
			  _.where = function(obj, attrs) {
			    return _.filter(obj, _.matches(attrs));
			  };

			  // Convenience version of a common use case of `find`: getting the first object
			  // containing specific `key:value` pairs.
			  _.findWhere = function(obj, attrs) {
			    return _.find(obj, _.matches(attrs));
			  };

			  // Return the maximum element (or element-based computation).
			  _.max = function(obj, iteratee, context) {
			    var result = -Infinity, lastComputed = -Infinity,
			        value, computed;
			    if (iteratee == null && obj != null) {
			      obj = obj.length === +obj.length ? obj : _.values(obj);
			      for (var i = 0, length = obj.length; i < length; i++) {
			        value = obj[i];
			        if (value > result) {
			          result = value;
			        }
			      }
			    } else {
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index, list) {
			        computed = iteratee(value, index, list);
			        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
			          result = value;
			          lastComputed = computed;
			        }
			      });
			    }
			    return result;
			  };

			  // Return the minimum element (or element-based computation).
			  _.min = function(obj, iteratee, context) {
			    var result = Infinity, lastComputed = Infinity,
			        value, computed;
			    if (iteratee == null && obj != null) {
			      obj = obj.length === +obj.length ? obj : _.values(obj);
			      for (var i = 0, length = obj.length; i < length; i++) {
			        value = obj[i];
			        if (value < result) {
			          result = value;
			        }
			      }
			    } else {
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index, list) {
			        computed = iteratee(value, index, list);
			        if (computed < lastComputed || computed === Infinity && result === Infinity) {
			          result = value;
			          lastComputed = computed;
			        }
			      });
			    }
			    return result;
			  };

			  // Shuffle a collection, using the modern version of the
			  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
			  _.shuffle = function(obj) {
			    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
			    var length = set.length;
			    var shuffled = Array(length);
			    for (var index = 0, rand; index < length; index++) {
			      rand = _.random(0, index);
			      if (rand !== index) shuffled[index] = shuffled[rand];
			      shuffled[rand] = set[index];
			    }
			    return shuffled;
			  };

			  // Sample **n** random values from a collection.
			  // If **n** is not specified, returns a single random element.
			  // The internal `guard` argument allows it to work with `map`.
			  _.sample = function(obj, n, guard) {
			    if (n == null || guard) {
			      if (obj.length !== +obj.length) obj = _.values(obj);
			      return obj[_.random(obj.length - 1)];
			    }
			    return _.shuffle(obj).slice(0, Math.max(0, n));
			  };

			  // Sort the object's values by a criterion produced by an iteratee.
			  _.sortBy = function(obj, iteratee, context) {
			    iteratee = _.iteratee(iteratee, context);
			    return _.pluck(_.map(obj, function(value, index, list) {
			      return {
			        value: value,
			        index: index,
			        criteria: iteratee(value, index, list)
			      };
			    }).sort(function(left, right) {
			      var a = left.criteria;
			      var b = right.criteria;
			      if (a !== b) {
			        if (a > b || a === void 0) return 1;
			        if (a < b || b === void 0) return -1;
			      }
			      return left.index - right.index;
			    }), 'value');
			  };

			  // An internal function used for aggregate "group by" operations.
			  var group = function(behavior) {
			    return function(obj, iteratee, context) {
			      var result = {};
			      iteratee = _.iteratee(iteratee, context);
			      _.each(obj, function(value, index) {
			        var key = iteratee(value, index, obj);
			        behavior(result, value, key);
			      });
			      return result;
			    };
			  };

			  // Groups the object's values by a criterion. Pass either a string attribute
			  // to group by, or a function that returns the criterion.
			  _.groupBy = group(function(result, value, key) {
			    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
			  });

			  // Indexes the object's values by a criterion, similar to `groupBy`, but for
			  // when you know that your index values will be unique.
			  _.indexBy = group(function(result, value, key) {
			    result[key] = value;
			  });

			  // Counts instances of an object that group by a certain criterion. Pass
			  // either a string attribute to count by, or a function that returns the
			  // criterion.
			  _.countBy = group(function(result, value, key) {
			    if (_.has(result, key)) result[key]++; else result[key] = 1;
			  });

			  // Use a comparator function to figure out the smallest index at which
			  // an object should be inserted so as to maintain order. Uses binary search.
			  _.sortedIndex = function(array, obj, iteratee, context) {
			    iteratee = _.iteratee(iteratee, context, 1);
			    var value = iteratee(obj);
			    var low = 0, high = array.length;
			    while (low < high) {
			      var mid = low + high >>> 1;
			      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
			    }
			    return low;
			  };

			  // Safely create a real, live array from anything iterable.
			  _.toArray = function(obj) {
			    if (!obj) return [];
			    if (_.isArray(obj)) return slice.call(obj);
			    if (obj.length === +obj.length) return _.map(obj, _.identity);
			    return _.values(obj);
			  };

			  // Return the number of elements in an object.
			  _.size = function(obj) {
			    if (obj == null) return 0;
			    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
			  };

			  // Split a collection into two arrays: one whose elements all satisfy the given
			  // predicate, and one whose elements all do not satisfy the predicate.
			  _.partition = function(obj, predicate, context) {
			    predicate = _.iteratee(predicate, context);
			    var pass = [], fail = [];
			    _.each(obj, function(value, key, obj) {
			      (predicate(value, key, obj) ? pass : fail).push(value);
			    });
			    return [pass, fail];
			  };

			  // Array Functions
			  // ---------------

			  // Get the first element of an array. Passing **n** will return the first N
			  // values in the array. Aliased as `head` and `take`. The **guard** check
			  // allows it to work with `_.map`.
			  _.first = _.head = _.take = function(array, n, guard) {
			    if (array == null) return void 0;
			    if (n == null || guard) return array[0];
			    if (n < 0) return [];
			    return slice.call(array, 0, n);
			  };

			  // Returns everything but the last entry of the array. Especially useful on
			  // the arguments object. Passing **n** will return all the values in
			  // the array, excluding the last N. The **guard** check allows it to work with
			  // `_.map`.
			  _.initial = function(array, n, guard) {
			    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
			  };

			  // Get the last element of an array. Passing **n** will return the last N
			  // values in the array. The **guard** check allows it to work with `_.map`.
			  _.last = function(array, n, guard) {
			    if (array == null) return void 0;
			    if (n == null || guard) return array[array.length - 1];
			    return slice.call(array, Math.max(array.length - n, 0));
			  };

			  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
			  // Especially useful on the arguments object. Passing an **n** will return
			  // the rest N values in the array. The **guard**
			  // check allows it to work with `_.map`.
			  _.rest = _.tail = _.drop = function(array, n, guard) {
			    return slice.call(array, n == null || guard ? 1 : n);
			  };

			  // Trim out all falsy values from an array.
			  _.compact = function(array) {
			    return _.filter(array, _.identity);
			  };

			  // Internal implementation of a recursive `flatten` function.
			  var flatten = function(input, shallow, strict, output) {
			    if (shallow && _.every(input, _.isArray)) {
			      return concat.apply(output, input);
			    }
			    for (var i = 0, length = input.length; i < length; i++) {
			      var value = input[i];
			      if (!_.isArray(value) && !_.isArguments(value)) {
			        if (!strict) output.push(value);
			      } else if (shallow) {
			        push.apply(output, value);
			      } else {
			        flatten(value, shallow, strict, output);
			      }
			    }
			    return output;
			  };

			  // Flatten out an array, either recursively (by default), or just one level.
			  _.flatten = function(array, shallow) {
			    return flatten(array, shallow, false, []);
			  };

			  // Return a version of the array that does not contain the specified value(s).
			  _.without = function(array) {
			    return _.difference(array, slice.call(arguments, 1));
			  };

			  // Produce a duplicate-free version of the array. If the array has already
			  // been sorted, you have the option of using a faster algorithm.
			  // Aliased as `unique`.
			  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
			    if (array == null) return [];
			    if (!_.isBoolean(isSorted)) {
			      context = iteratee;
			      iteratee = isSorted;
			      isSorted = false;
			    }
			    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
			    var result = [];
			    var seen = [];
			    for (var i = 0, length = array.length; i < length; i++) {
			      var value = array[i];
			      if (isSorted) {
			        if (!i || seen !== value) result.push(value);
			        seen = value;
			      } else if (iteratee) {
			        var computed = iteratee(value, i, array);
			        if (_.indexOf(seen, computed) < 0) {
			          seen.push(computed);
			          result.push(value);
			        }
			      } else if (_.indexOf(result, value) < 0) {
			        result.push(value);
			      }
			    }
			    return result;
			  };

			  // Produce an array that contains the union: each distinct element from all of
			  // the passed-in arrays.
			  _.union = function() {
			    return _.uniq(flatten(arguments, true, true, []));
			  };

			  // Produce an array that contains every item shared between all the
			  // passed-in arrays.
			  _.intersection = function(array) {
			    if (array == null) return [];
			    var result = [];
			    var argsLength = arguments.length;
			    for (var i = 0, length = array.length; i < length; i++) {
			      var item = array[i];
			      if (_.contains(result, item)) continue;
			      for (var j = 1; j < argsLength; j++) {
			        if (!_.contains(arguments[j], item)) break;
			      }
			      if (j === argsLength) result.push(item);
			    }
			    return result;
			  };

			  // Take the difference between one array and a number of other arrays.
			  // Only the elements present in just the first array will remain.
			  _.difference = function(array) {
			    var rest = flatten(slice.call(arguments, 1), true, true, []);
			    return _.filter(array, function(value){
			      return !_.contains(rest, value);
			    });
			  };

			  // Zip together multiple lists into a single array -- elements that share
			  // an index go together.
			  _.zip = function(array) {
			    if (array == null) return [];
			    var length = _.max(arguments, 'length').length;
			    var results = Array(length);
			    for (var i = 0; i < length; i++) {
			      results[i] = _.pluck(arguments, i);
			    }
			    return results;
			  };

			  // Converts lists into objects. Pass either a single array of `[key, value]`
			  // pairs, or two parallel arrays of the same length -- one of keys, and one of
			  // the corresponding values.
			  _.object = function(list, values) {
			    if (list == null) return {};
			    var result = {};
			    for (var i = 0, length = list.length; i < length; i++) {
			      if (values) {
			        result[list[i]] = values[i];
			      } else {
			        result[list[i][0]] = list[i][1];
			      }
			    }
			    return result;
			  };

			  // Return the position of the first occurrence of an item in an array,
			  // or -1 if the item is not included in the array.
			  // If the array is large and already in sort order, pass `true`
			  // for **isSorted** to use binary search.
			  _.indexOf = function(array, item, isSorted) {
			    if (array == null) return -1;
			    var i = 0, length = array.length;
			    if (isSorted) {
			      if (typeof isSorted == 'number') {
			        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
			      } else {
			        i = _.sortedIndex(array, item);
			        return array[i] === item ? i : -1;
			      }
			    }
			    for (; i < length; i++) if (array[i] === item) return i;
			    return -1;
			  };

			  _.lastIndexOf = function(array, item, from) {
			    if (array == null) return -1;
			    var idx = array.length;
			    if (typeof from == 'number') {
			      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
			    }
			    while (--idx >= 0) if (array[idx] === item) return idx;
			    return -1;
			  };

			  // Generate an integer Array containing an arithmetic progression. A port of
			  // the native Python `range()` function. See
			  // [the Python documentation](http://docs.python.org/library/functions.html#range).
			  _.range = function(start, stop, step) {
			    if (arguments.length <= 1) {
			      stop = start || 0;
			      start = 0;
			    }
			    step = step || 1;

			    var length = Math.max(Math.ceil((stop - start) / step), 0);
			    var range = Array(length);

			    for (var idx = 0; idx < length; idx++, start += step) {
			      range[idx] = start;
			    }

			    return range;
			  };

			  // Function (ahem) Functions
			  // ------------------

			  // Reusable constructor function for prototype setting.
			  var Ctor = function(){};

			  // Create a function bound to a given object (assigning `this`, and arguments,
			  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
			  // available.
			  _.bind = function(func, context) {
			    var args, bound;
			    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
			    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
			    args = slice.call(arguments, 2);
			    bound = function() {
			      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
			      Ctor.prototype = func.prototype;
			      var self = new Ctor;
			      Ctor.prototype = null;
			      var result = func.apply(self, args.concat(slice.call(arguments)));
			      if (_.isObject(result)) return result;
			      return self;
			    };
			    return bound;
			  };

			  // Partially apply a function by creating a version that has had some of its
			  // arguments pre-filled, without changing its dynamic `this` context. _ acts
			  // as a placeholder, allowing any combination of arguments to be pre-filled.
			  _.partial = function(func) {
			    var boundArgs = slice.call(arguments, 1);
			    return function() {
			      var position = 0;
			      var args = boundArgs.slice();
			      for (var i = 0, length = args.length; i < length; i++) {
			        if (args[i] === _) args[i] = arguments[position++];
			      }
			      while (position < arguments.length) args.push(arguments[position++]);
			      return func.apply(this, args);
			    };
			  };

			  // Bind a number of an object's methods to that object. Remaining arguments
			  // are the method names to be bound. Useful for ensuring that all callbacks
			  // defined on an object belong to it.
			  _.bindAll = function(obj) {
			    var i, length = arguments.length, key;
			    if (length <= 1) throw new Error('bindAll must be passed function names');
			    for (i = 1; i < length; i++) {
			      key = arguments[i];
			      obj[key] = _.bind(obj[key], obj);
			    }
			    return obj;
			  };

			  // Memoize an expensive function by storing its results.
			  _.memoize = function(func, hasher) {
			    var memoize = function(key) {
			      var cache = memoize.cache;
			      var address = hasher ? hasher.apply(this, arguments) : key;
			      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
			      return cache[address];
			    };
			    memoize.cache = {};
			    return memoize;
			  };

			  // Delays a function for the given number of milliseconds, and then calls
			  // it with the arguments supplied.
			  _.delay = function(func, wait) {
			    var args = slice.call(arguments, 2);
			    return setTimeout(function(){
			      return func.apply(null, args);
			    }, wait);
			  };

			  // Defers a function, scheduling it to run after the current call stack has
			  // cleared.
			  _.defer = function(func) {
			    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
			  };

			  // Returns a function, that, when invoked, will only be triggered at most once
			  // during a given window of time. Normally, the throttled function will run
			  // as much as it can, without ever going more than once per `wait` duration;
			  // but if you'd like to disable the execution on the leading edge, pass
			  // `{leading: false}`. To disable execution on the trailing edge, ditto.
			  _.throttle = function(func, wait, options) {
			    var context, args, result;
			    var timeout = null;
			    var previous = 0;
			    if (!options) options = {};
			    var later = function() {
			      previous = options.leading === false ? 0 : _.now();
			      timeout = null;
			      result = func.apply(context, args);
			      if (!timeout) context = args = null;
			    };
			    return function() {
			      var now = _.now();
			      if (!previous && options.leading === false) previous = now;
			      var remaining = wait - (now - previous);
			      context = this;
			      args = arguments;
			      if (remaining <= 0 || remaining > wait) {
			        clearTimeout(timeout);
			        timeout = null;
			        previous = now;
			        result = func.apply(context, args);
			        if (!timeout) context = args = null;
			      } else if (!timeout && options.trailing !== false) {
			        timeout = setTimeout(later, remaining);
			      }
			      return result;
			    };
			  };

			  // Returns a function, that, as long as it continues to be invoked, will not
			  // be triggered. The function will be called after it stops being called for
			  // N milliseconds. If `immediate` is passed, trigger the function on the
			  // leading edge, instead of the trailing.
			  _.debounce = function(func, wait, immediate) {
			    var timeout, args, context, timestamp, result;

			    var later = function() {
			      var last = _.now() - timestamp;

			      if (last < wait && last > 0) {
			        timeout = setTimeout(later, wait - last);
			      } else {
			        timeout = null;
			        if (!immediate) {
			          result = func.apply(context, args);
			          if (!timeout) context = args = null;
			        }
			      }
			    };

			    return function() {
			      context = this;
			      args = arguments;
			      timestamp = _.now();
			      var callNow = immediate && !timeout;
			      if (!timeout) timeout = setTimeout(later, wait);
			      if (callNow) {
			        result = func.apply(context, args);
			        context = args = null;
			      }

			      return result;
			    };
			  };

			  // Returns the first function passed as an argument to the second,
			  // allowing you to adjust arguments, run code before and after, and
			  // conditionally execute the original function.
			  _.wrap = function(func, wrapper) {
			    return _.partial(wrapper, func);
			  };

			  // Returns a negated version of the passed-in predicate.
			  _.negate = function(predicate) {
			    return function() {
			      return !predicate.apply(this, arguments);
			    };
			  };

			  // Returns a function that is the composition of a list of functions, each
			  // consuming the return value of the function that follows.
			  _.compose = function() {
			    var args = arguments;
			    var start = args.length - 1;
			    return function() {
			      var i = start;
			      var result = args[start].apply(this, arguments);
			      while (i--) result = args[i].call(this, result);
			      return result;
			    };
			  };

			  // Returns a function that will only be executed after being called N times.
			  _.after = function(times, func) {
			    return function() {
			      if (--times < 1) {
			        return func.apply(this, arguments);
			      }
			    };
			  };

			  // Returns a function that will only be executed before being called N times.
			  _.before = function(times, func) {
			    var memo;
			    return function() {
			      if (--times > 0) {
			        memo = func.apply(this, arguments);
			      } else {
			        func = null;
			      }
			      return memo;
			    };
			  };

			  // Returns a function that will be executed at most one time, no matter how
			  // often you call it. Useful for lazy initialization.
			  _.once = _.partial(_.before, 2);

			  // Object Functions
			  // ----------------

			  // Retrieve the names of an object's properties.
			  // Delegates to **ECMAScript 5**'s native `Object.keys`
			  _.keys = function(obj) {
			    if (!_.isObject(obj)) return [];
			    if (nativeKeys) return nativeKeys(obj);
			    var keys = [];
			    for (var key in obj) if (_.has(obj, key)) keys.push(key);
			    return keys;
			  };

			  // Retrieve the values of an object's properties.
			  _.values = function(obj) {
			    var keys = _.keys(obj);
			    var length = keys.length;
			    var values = Array(length);
			    for (var i = 0; i < length; i++) {
			      values[i] = obj[keys[i]];
			    }
			    return values;
			  };

			  // Convert an object into a list of `[key, value]` pairs.
			  _.pairs = function(obj) {
			    var keys = _.keys(obj);
			    var length = keys.length;
			    var pairs = Array(length);
			    for (var i = 0; i < length; i++) {
			      pairs[i] = [keys[i], obj[keys[i]]];
			    }
			    return pairs;
			  };

			  // Invert the keys and values of an object. The values must be serializable.
			  _.invert = function(obj) {
			    var result = {};
			    var keys = _.keys(obj);
			    for (var i = 0, length = keys.length; i < length; i++) {
			      result[obj[keys[i]]] = keys[i];
			    }
			    return result;
			  };

			  // Return a sorted list of the function names available on the object.
			  // Aliased as `methods`
			  _.functions = _.methods = function(obj) {
			    var names = [];
			    for (var key in obj) {
			      if (_.isFunction(obj[key])) names.push(key);
			    }
			    return names.sort();
			  };

			  // Extend a given object with all the properties in passed-in object(s).
			  _.extend = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    var source, prop;
			    for (var i = 1, length = arguments.length; i < length; i++) {
			      source = arguments[i];
			      for (prop in source) {
			        if (hasOwnProperty.call(source, prop)) {
			            obj[prop] = source[prop];
			        }
			      }
			    }
			    return obj;
			  };

			  // Return a copy of the object only containing the whitelisted properties.
			  _.pick = function(obj, iteratee, context) {
			    var result = {}, key;
			    if (obj == null) return result;
			    if (_.isFunction(iteratee)) {
			      iteratee = createCallback(iteratee, context);
			      for (key in obj) {
			        var value = obj[key];
			        if (iteratee(value, key, obj)) result[key] = value;
			      }
			    } else {
			      var keys = concat.apply([], slice.call(arguments, 1));
			      obj = new Object(obj);
			      for (var i = 0, length = keys.length; i < length; i++) {
			        key = keys[i];
			        if (key in obj) result[key] = obj[key];
			      }
			    }
			    return result;
			  };

			   // Return a copy of the object without the blacklisted properties.
			  _.omit = function(obj, iteratee, context) {
			    if (_.isFunction(iteratee)) {
			      iteratee = _.negate(iteratee);
			    } else {
			      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
			      iteratee = function(value, key) {
			        return !_.contains(keys, key);
			      };
			    }
			    return _.pick(obj, iteratee, context);
			  };

			  // Fill in a given object with default properties.
			  _.defaults = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    for (var i = 1, length = arguments.length; i < length; i++) {
			      var source = arguments[i];
			      for (var prop in source) {
			        if (obj[prop] === void 0) obj[prop] = source[prop];
			      }
			    }
			    return obj;
			  };

			  // Create a (shallow-cloned) duplicate of an object.
			  _.clone = function(obj) {
			    if (!_.isObject(obj)) return obj;
			    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
			  };

			  // Invokes interceptor with the obj, and then returns obj.
			  // The primary purpose of this method is to "tap into" a method chain, in
			  // order to perform operations on intermediate results within the chain.
			  _.tap = function(obj, interceptor) {
			    interceptor(obj);
			    return obj;
			  };

			  // Internal recursive comparison function for `isEqual`.
			  var eq = function(a, b, aStack, bStack) {
			    // Identical objects are equal. `0 === -0`, but they aren't identical.
			    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
			    if (a === b) return a !== 0 || 1 / a === 1 / b;
			    // A strict comparison is necessary because `null == undefined`.
			    if (a == null || b == null) return a === b;
			    // Unwrap any wrapped objects.
			    if (a instanceof _) a = a._wrapped;
			    if (b instanceof _) b = b._wrapped;
			    // Compare `[[Class]]` names.
			    var className = toString.call(a);
			    if (className !== toString.call(b)) return false;
			    switch (className) {
			      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
			      case '[object RegExp]':
			      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
			      case '[object String]':
			        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
			        // equivalent to `new String("5")`.
			        return '' + a === '' + b;
			      case '[object Number]':
			        // `NaN`s are equivalent, but non-reflexive.
			        // Object(NaN) is equivalent to NaN
			        if (+a !== +a) return +b !== +b;
			        // An `egal` comparison is performed for other numeric values.
			        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
			      case '[object Date]':
			      case '[object Boolean]':
			        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
			        // millisecond representations. Note that invalid dates with millisecond representations
			        // of `NaN` are not equivalent.
			        return +a === +b;
			    }
			    if (typeof a != 'object' || typeof b != 'object') return false;
			    // Assume equality for cyclic structures. The algorithm for detecting cyclic
			    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
			    var length = aStack.length;
			    while (length--) {
			      // Linear search. Performance is inversely proportional to the number of
			      // unique nested structures.
			      if (aStack[length] === a) return bStack[length] === b;
			    }
			    // Objects with different constructors are not equivalent, but `Object`s
			    // from different frames are.
			    var aCtor = a.constructor, bCtor = b.constructor;
			    if (
			      aCtor !== bCtor &&
			      // Handle Object.create(x) cases
			      'constructor' in a && 'constructor' in b &&
			      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
			        _.isFunction(bCtor) && bCtor instanceof bCtor)
			    ) {
			      return false;
			    }
			    // Add the first object to the stack of traversed objects.
			    aStack.push(a);
			    bStack.push(b);
			    var size, result;
			    // Recursively compare objects and arrays.
			    if (className === '[object Array]') {
			      // Compare array lengths to determine if a deep comparison is necessary.
			      size = a.length;
			      result = size === b.length;
			      if (result) {
			        // Deep compare the contents, ignoring non-numeric properties.
			        while (size--) {
			          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
			        }
			      }
			    } else {
			      // Deep compare objects.
			      var keys = _.keys(a), key;
			      size = keys.length;
			      // Ensure that both objects contain the same number of properties before comparing deep equality.
			      result = _.keys(b).length === size;
			      if (result) {
			        while (size--) {
			          // Deep compare each member
			          key = keys[size];
			          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
			        }
			      }
			    }
			    // Remove the first object from the stack of traversed objects.
			    aStack.pop();
			    bStack.pop();
			    return result;
			  };

			  // Perform a deep comparison to check if two objects are equal.
			  _.isEqual = function(a, b) {
			    return eq(a, b, [], []);
			  };

			  // Is a given array, string, or object empty?
			  // An "empty" object has no enumerable own-properties.
			  _.isEmpty = function(obj) {
			    if (obj == null) return true;
			    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
			    for (var key in obj) if (_.has(obj, key)) return false;
			    return true;
			  };

			  // Is a given value a DOM element?
			  _.isElement = function(obj) {
			    return !!(obj && obj.nodeType === 1);
			  };

			  // Is a given value an array?
			  // Delegates to ECMA5's native Array.isArray
			  _.isArray = nativeIsArray || function(obj) {
			    return toString.call(obj) === '[object Array]';
			  };

			  // Is a given variable an object?
			  _.isObject = function(obj) {
			    var type = typeof obj;
			    return type === 'function' || type === 'object' && !!obj;
			  };

			  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
			  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
			    _['is' + name] = function(obj) {
			      return toString.call(obj) === '[object ' + name + ']';
			    };
			  });

			  // Define a fallback version of the method in browsers (ahem, IE), where
			  // there isn't any inspectable "Arguments" type.
			  if (!_.isArguments(arguments)) {
			    _.isArguments = function(obj) {
			      return _.has(obj, 'callee');
			    };
			  }

			  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
			  if (typeof /./ !== 'function') {
			    _.isFunction = function(obj) {
			      return typeof obj == 'function' || false;
			    };
			  }

			  // Is a given object a finite number?
			  _.isFinite = function(obj) {
			    return isFinite(obj) && !isNaN(parseFloat(obj));
			  };

			  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
			  _.isNaN = function(obj) {
			    return _.isNumber(obj) && obj !== +obj;
			  };

			  // Is a given value a boolean?
			  _.isBoolean = function(obj) {
			    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
			  };

			  // Is a given value equal to null?
			  _.isNull = function(obj) {
			    return obj === null;
			  };

			  // Is a given variable undefined?
			  _.isUndefined = function(obj) {
			    return obj === void 0;
			  };

			  // Shortcut function for checking if an object has a given property directly
			  // on itself (in other words, not on a prototype).
			  _.has = function(obj, key) {
			    return obj != null && hasOwnProperty.call(obj, key);
			  };

			  // Utility Functions
			  // -----------------

			  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
			  // previous owner. Returns a reference to the Underscore object.
			  _.noConflict = function() {
			    root._ = previousUnderscore;
			    return this;
			  };

			  // Keep the identity function around for default iteratees.
			  _.identity = function(value) {
			    return value;
			  };

			  _.constant = function(value) {
			    return function() {
			      return value;
			    };
			  };

			  _.noop = function(){};

			  _.property = function(key) {
			    return function(obj) {
			      return obj[key];
			    };
			  };

			  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
			  _.matches = function(attrs) {
			    var pairs = _.pairs(attrs), length = pairs.length;
			    return function(obj) {
			      if (obj == null) return !length;
			      obj = new Object(obj);
			      for (var i = 0; i < length; i++) {
			        var pair = pairs[i], key = pair[0];
			        if (pair[1] !== obj[key] || !(key in obj)) return false;
			      }
			      return true;
			    };
			  };

			  // Run a function **n** times.
			  _.times = function(n, iteratee, context) {
			    var accum = Array(Math.max(0, n));
			    iteratee = createCallback(iteratee, context, 1);
			    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
			    return accum;
			  };

			  // Return a random integer between min and max (inclusive).
			  _.random = function(min, max) {
			    if (max == null) {
			      max = min;
			      min = 0;
			    }
			    return min + Math.floor(Math.random() * (max - min + 1));
			  };

			  // A (possibly faster) way to get the current timestamp as an integer.
			  _.now = Date.now || function() {
			    return new Date().getTime();
			  };

			   // List of HTML entities for escaping.
			  var escapeMap = {
			    '&': '&amp;',
			    '<': '&lt;',
			    '>': '&gt;',
			    '"': '&quot;',
			    "'": '&#x27;',
			    '`': '&#x60;'
			  };
			  var unescapeMap = _.invert(escapeMap);

			  // Functions for escaping and unescaping strings to/from HTML interpolation.
			  var createEscaper = function(map) {
			    var escaper = function(match) {
			      return map[match];
			    };
			    // Regexes for identifying a key that needs to be escaped
			    var source = '(?:' + _.keys(map).join('|') + ')';
			    var testRegexp = RegExp(source);
			    var replaceRegexp = RegExp(source, 'g');
			    return function(string) {
			      string = string == null ? '' : '' + string;
			      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
			    };
			  };
			  _.escape = createEscaper(escapeMap);
			  _.unescape = createEscaper(unescapeMap);

			  // If the value of the named `property` is a function then invoke it with the
			  // `object` as context; otherwise, return it.
			  _.result = function(object, property) {
			    if (object == null) return void 0;
			    var value = object[property];
			    return _.isFunction(value) ? object[property]() : value;
			  };

			  // Generate a unique integer id (unique within the entire client session).
			  // Useful for temporary DOM ids.
			  var idCounter = 0;
			  _.uniqueId = function(prefix) {
			    var id = ++idCounter + '';
			    return prefix ? prefix + id : id;
			  };

			  // By default, Underscore uses ERB-style template delimiters, change the
			  // following template settings to use alternative delimiters.
			  _.templateSettings = {
			    evaluate    : /<%([\s\S]+?)%>/g,
			    interpolate : /<%=([\s\S]+?)%>/g,
			    escape      : /<%-([\s\S]+?)%>/g
			  };

			  // When customizing `templateSettings`, if you don't want to define an
			  // interpolation, evaluation or escaping regex, we need one that is
			  // guaranteed not to match.
			  var noMatch = /(.)^/;

			  // Certain characters need to be escaped so that they can be put into a
			  // string literal.
			  var escapes = {
			    "'":      "'",
			    '\\':     '\\',
			    '\r':     'r',
			    '\n':     'n',
			    '\u2028': 'u2028',
			    '\u2029': 'u2029'
			  };

			  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

			  var escapeChar = function(match) {
			    return '\\' + escapes[match];
			  };

			  // JavaScript micro-templating, similar to John Resig's implementation.
			  // Underscore templating handles arbitrary delimiters, preserves whitespace,
			  // and correctly escapes quotes within interpolated code.
			  // NB: `oldSettings` only exists for backwards compatibility.
			  _.template = function(text, settings, oldSettings) {
			    if (!settings && oldSettings) settings = oldSettings;
			    settings = _.defaults({}, settings, _.templateSettings);

			    // Combine delimiters into one regular expression via alternation.
			    var matcher = RegExp([
			      (settings.escape || noMatch).source,
			      (settings.interpolate || noMatch).source,
			      (settings.evaluate || noMatch).source
			    ].join('|') + '|$', 'g');

			    // Compile the template source, escaping string literals appropriately.
			    var index = 0;
			    var source = "__p+='";
			    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
			      source += text.slice(index, offset).replace(escaper, escapeChar);
			      index = offset + match.length;

			      if (escape) {
			        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
			      } else if (interpolate) {
			        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
			      } else if (evaluate) {
			        source += "';\n" + evaluate + "\n__p+='";
			      }

			      // Adobe VMs need the match returned to produce the correct offest.
			      return match;
			    });
			    source += "';\n";

			    // If a variable is not specified, place data values in local scope.
			    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

			    source = "var __t,__p='',__j=Array.prototype.join," +
			      "print=function(){__p+=__j.call(arguments,'');};\n" +
			      source + 'return __p;\n';

			    try {
			      var render = new Function(settings.variable || 'obj', '_', source);
			    } catch (e) {
			      e.source = source;
			      throw e;
			    }

			    var template = function(data) {
			      return render.call(this, data, _);
			    };

			    // Provide the compiled source as a convenience for precompilation.
			    var argument = settings.variable || 'obj';
			    template.source = 'function(' + argument + '){\n' + source + '}';

			    return template;
			  };

			  // Add a "chain" function. Start chaining a wrapped Underscore object.
			  _.chain = function(obj) {
			    var instance = _(obj);
			    instance._chain = true;
			    return instance;
			  };

			  // OOP
			  // ---------------
			  // If Underscore is called as a function, it returns a wrapped object that
			  // can be used OO-style. This wrapper holds altered versions of all the
			  // underscore functions. Wrapped objects may be chained.

			  // Helper function to continue chaining intermediate results.
			  var result = function(obj) {
			    return this._chain ? _(obj).chain() : obj;
			  };

			  // Add your own custom functions to the Underscore object.
			  _.mixin = function(obj) {
			    _.each(_.functions(obj), function(name) {
			      var func = _[name] = obj[name];
			      _.prototype[name] = function() {
			        var args = [this._wrapped];
			        push.apply(args, arguments);
			        return result.call(this, func.apply(_, args));
			      };
			    });
			  };

			  // Add all of the Underscore functions to the wrapper object.
			  _.mixin(_);

			  // Add all mutator Array functions to the wrapper.
			  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
			    var method = ArrayProto[name];
			    _.prototype[name] = function() {
			      var obj = this._wrapped;
			      method.apply(obj, arguments);
			      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
			      return result.call(this, obj);
			    };
			  });

			  // Add all accessor Array functions to the wrapper.
			  _.each(['concat', 'join', 'slice'], function(name) {
			    var method = ArrayProto[name];
			    _.prototype[name] = function() {
			      return result.call(this, method.apply(this._wrapped, arguments));
			    };
			  });

			  // Extracts the result from a wrapped and chained object.
			  _.prototype.value = function() {
			    return this._wrapped;
			  };

			  // AMD registration happens at the end for compatibility with AMD loaders
			  // that may not enforce next-turn semantics on modules. Even though general
			  // practice for AMD registration is to be anonymous, underscore registers
			  // as a named module because, like jQuery, it is a base library that is
			  // popular enough to be bundled in a third party lib, but not be part of
			  // an AMD load request. Those cases could generate an error when an
			  // anonymous define() is called outside of a loader request.
			  if (typeof define === 'function' && define.amd) {
			    define('underscore', [], function() {
			      return _;
			    });
			  }
			}.call(this));
		}
	}
})("dust2/src/index");
